## [42. Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)

### Brute Force
Iterate every height, and find the left and right max height from current height. It takes `O(n^2)` time.

```kotlin
fun trap(height: IntArray): Int {
    var result = 0
    for (current in 0 until height.size) {
        var leftMax = 0
        var rightMax = 0
        for (i in current downTo 0) {
            leftMax = if (height[i] > leftMax) height[i] else leftMax
        }
        for (i in current until height.size) {
            rightMax = if (height[i] > rightMax) height[i] else rightMax
        }
        result += (if (leftMax > rightMax) rightMax else leftMax) - height[current]
    }
    return result
}
```

### Dynamic Programming
We can improve the running time from brute force solution, we store every left max and right max for every position (memoization), the time complexity reduces to `O(n)`, but space compexity increase to `O(n)` as well. Then iterate to calculate the result for every position.

```kotlin
fun trap(height: IntArray): Int {
    var result = 0
    var leftMax = 0
    var rightMax = 0
    val leftMaxs = IntArray(height.size)
    val rightMaxs = IntArray(height.size)

    // Find the left max height for every position
    for (current in 0 until height.size) {
        leftMax = if (height[current] > leftMax) height[current] else leftMax
        leftMaxs[current] = leftMax
    }
    // Find the right max height for every position
    for (current in height.size - 1 downTo 0) {
        rightMax = if (height[current] > rightMax) height[current] else rightMax
        rightMaxs[current] = rightMax
    }

    // Then calculate the result for every position from above left/right max height.
    for (current in 0 until height.size) {
        result += (if (leftMaxs[current] > rightMaxs[current]) rightMaxs[current] else leftMaxs[current]) - height[current]
    }
    return result
}
```

### Monotonic Stack
We use monotonic stack (decreasing) to trace the maximum area for trapping.

```kotlin
fun trap(height: IntArray): Int {
    // We store the index
    val stack = Stack<Int>()
    var trap = 0
    // Loop as right wall
    for (rightIndex in 0 until height.size) {
        val rightHeight = height[rightIndex]

        // When we find a valid right wall, then go back to find the ground and left height.
        while (!stack.isEmpty() && rightHeight > height[stack.peek()]) {
            val groundIndex = stack.pop()
            
            // If there is not left wall, then can't trap.
            if (stack.isEmpty()) break
            
            val leftIndex = stack.peek()

            // For [7 1 4] we can trap max height to 4, not 7.
            val minHeight = min(height[leftIndex], rightHeight) - height[groundIndex]
            val width = i - leftIndex - 1
            trap += minHeight * width
        }
        stack.push(i)
    }
    return trap
}
```

![42](../media/42.trapping-rain-water.png)
> Source: https://leetcode.cn/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode/