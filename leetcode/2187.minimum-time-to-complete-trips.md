# [2187. Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/description/)

## Linear Search
The current time / time[i] = the number of trips that can be completed within the current time. We can start from the minimum speed `1`, and check if it's possible to complete all trips within the given `hour` hours. If not, we increase the speed by 1 and check again.
```js
// required time / time[i] = # trips >= totalTrips?

t = 1
[1, 2, 3]
1/1 + 1/2 + 1/3 = 1 + 0 + 0 = 1 < 5

t = 2
2/1 + 2/2 + 2/3 = 2 + 1 + 0 = 3 < 5

t = 3
3/1 + 3/2 + 3/3 = 3 + 1 + 1 = 5 >= 5
```

```kotlin
fun minimumTime(time: IntArray, totalTrips: Int): Long {
    var requiredTime = 1L
    var trips = 0
    while (trips < totalTrips) {
        trips = 0
        for (t in time) {
            trips += requiredTime / t
        }
        if (totalTrips <= trips) break
        requiredTime++
    }
    return requiredTime
}
```

## Binary Search
We can optimize the linear search solution with some modifications based on some key observations:
1. The minimum time is `1`, and the maximum time is the maximum of possible value, which is `10^7` or `the minimal time * totalTrips` (the fastest bus).
2. As we increase the time, tht number of trips that can be completed within the current time is larget, and vice versa. This exhibits the **monotonicity** characteristic, so we can use binary search to find the minimum time: **We're looking for the first element that satisfies the condition: `totalTrips <= trips`**.

```js
// required time
 1  2  3  4  5  6  7, ...
[X, X, X, O, O, O, O]
          ^ // The minimum time to complete all trips
```

```kotlin
fun minimumTime(time: IntArray, totalTrips: Int): Long {
    var min = Long.MAX_VALUE
    for (t in time) {
        min = minOf(min, t.toLong())
    }

    var left = 1L
    var right = min * totalTrips
    while (left <= right) {
        val middle = left + (right - left) / 2
        val isValid = totalTrips <= getTotalTrips(time, middle)
        if (isValid) {
            right = middle - 1
        } else {
            left = middle + 1
        }
    }
    return left
}

private fun getTotalTrips(times: IntArray, requiredTime: Long): Long {
    var totalTrips = 0L
    for (t in times) {
        totalTrips += requiredTime / t.toLong()
    }
    return totalTrips
}
```