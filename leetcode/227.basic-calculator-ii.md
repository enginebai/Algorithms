# [227. Basic Calculator II](https://leetcode.com/problems/basic-calculator-ii/description/)

This is a series of calculator problems:
* [227. Basic Calculator II](../leetcode/227.basic-calculator-ii.md)
* [224. Basic Calculator](../leetcode/224.basic-calculator.md)
* [772. Basic Calculator III](https://leetcode.com/problems/basic-calculator-iii/description/) (Premium): Which contains `+-*/` and `()` operations, and the number can be more than one digit.

Before solving this problem, we can break down the problems into several parts:
## 1. Parsing Number

```kotlin
val s = "1234"
var num = 0
for (c in s) {
    num = num * 10 + (c - '0')
}
return num
```

## 2. Simple Addition and Subtraction
For s = `300 + 10 - 5`, how to calculate? There are some key ideas:
1. We treat every item as [`operator` and `number`]: `+300`, `+10`, `-5`
1. We push the number before the operator into the stack: We iterate the string (skip the space) and parse the number **until the next operator or the end of the string**, then push the number into the stack. 
1. We sum up all the elements in the stack: `[+300, +10, -5] = 305`

> Please mind the special case: The last number, because there is no operator after the last number, we also have to push it into the stack.

For example, s = `"300 + 10 - 5"`, the iteration process is:

```js
s = "300 + 10 - 5"
    i 
// Before iteration:
num = 0
operator = '+'
stack = []

s = "300 + 10 - 5"
         i 
// After parsing 300, encountering `+`:
num = 300
operator = '+' // The operator for 300
stack = [+300]
operator = '+' // Update the operator after 300

s = "300 + 10 - 5"
              i 
// After parsing 10, encountering `-`:
num = 10
operator = '+' // The operator for 10
stack = [+300, +10]
operator = '-' // Update the operator after 10

s = "300 + 10 - 5"
                i 
// After parsing 5, end of the string:
num = 5
operator = '-' // The operator for 5
stack = [+300, +10, -5]
```

> Question: What if we have `-300 + 10 ...`, the starting number is negative?

The key difference is that we will push `+0` (the initial and "invisible" number before `-`) into the stack when encountering the first `-` at the beginning:
```js
s = "-300 + 10 - 5"
    i 
// Before iteration:
num = 0
operator = '+'
stack = []

s = "-300 + 10 - 5"
     i 
// Encountering `-`:
num = 0
operator = '+' // The operator for 0
stack = [+0]
operator = '-' // Update the operator after 0, that is `-` for `-300`

// After parsing -300, encountering `+`:
Same as above.
stack = [+0, -300]

// The remaining process is the same as above.
```

```kotlin
fun calculate(s: String): Int {
    val stack = Stack<Int>()
    var num = 0
    var sign = '+' // We initialize the sign as `+` at the beginning of the string
    for (i in 0 until s.length) {
        val c = s[i]
        if (c.isDigit()) {
            num = num * 10 + (c - '0')
        }

        // If the character is a operator or the last number, see below explanation:
        // +300+ ...
        //     c        We should push +300 into the stack
        //          -5
        //           c  We should push -5 into the stack for the         
        if ((!c.isDigit() && c != ' ') || i == s.lenght - 1) {
            // We push the operator and number into the stack when we encounter the next operator (current index i)
            // This is the previous sign and the number next to it
            when (sign) {
                '+' -> stack.push(num)
                '-' -> stack.push(-num)
            }   
            // Update to the current sign
            sign = c
            // Reset the number for the next number
            num = 0
        }
    }
    // Stack: [+0, +300, +10, -5]
    var sum = 0
    while (stack.isNotEmpty()) {
        sum += stack.pop()
    }
    return sum
}
```

Let's explain the code:
```kotlin
...
// 300 + 10 - 5
//          ^ i is here, next to `+10`
if (!c.isDigit() && c != ' ' || i == s.lenght - 1) {
    // Push `+10` into stack
    when (sign) {               // sign = `+` before 10
        '+' -> stack.push(num)  // num = 10
        '-' -> stack.push(-num)
    }   
    // Update to the current sign
    sign = c  // sign = `-` before 5
    // Reset the number for the next number
    num = 0
}
...

```js
      i
_ 300 + 10 - 5
|   |
|   num = 300
sign = + // We initialize the sign as `+` at the beginning of the string

stack = [+300]

// Next operator
         i
300 + 10 - 5
    |  | 
    |  num = 10
    sign = +

stack = [+300, +10]
```

## 3. Original Problem
After understanding the above concepts, now we can solve the original problem. The difference between this problem and the previous one is that we have to calculate the multiplication and division first.

We can still use stack to solve the precedence, we calculate all the results of `*` and `/` first which has high precedence than `+` and `-`, and then every item will be a plus or minus numbers that have the same precedence after we iterate the string, we can sum them up to get the result.

Based on this idea, we can iterate the string and parse the number after the operator:
* If the operator is `+` or `-`, we push the number into the stack.
* If the operator is `*` or `/`, because we have to calculate the result immediately which `*` and `/`, **we pop the last number from the stack, calculate the result, and push it back to the stack**. This is how we calculate the multiplication and division first.

```js
s = "3 - 2 * 5 / 2 + 7"

// Trim the space and append a "+" at the beginning of the string
s = "+3-2*5/2+7"

s = "+3-2*5/2+7"
     ^^ // Push +3 into stack
stack = [+0, +3] 

s = "+3-2*5/2+7"
       ^^ // Push -2 into stack
stack = [+0, +3, -2] 

s = "+3-2*5/2+7"
         ^^ 
stack = [+0, +3, -10] // We pop -2 and calculate -2 * 5 = -10, then push -10 back to stack

s = "+3-2*5/2+7"
           ^^ 
stack = [+0 +3, -5] // We pop -10 and calculate -10 / 2 = -5, then push -5 back to stack

s = "+3-2*5/2+7"
             ^^ // Push +7 into stack
stack = [+0, +3, -5, +7]

// Sum up all the elements in stack: 3 - 5 + 7 = 5
return 5 
```
 
```kotlin
fun calculate(s: String): Int {
    val stack = Stack<Int>()
    var num = 0
    var operation: Char = '+'
    val operationSet = hashSetOf('+', '-', '*', '/')
    for (i in 0 until s.length) {
        val c = s[i]
        if (c.isDigit()) {
            // Wrong to use `c.toInt()` is the ASCII code of the character, not the number
            num = num * 10 + (c - '0')
        }
        // Here we can't use `else if` because we have to push the last number into the stack
        if (operationSet.contains(c) || i == s.length - 1) {
            // `c` is the current operator, and `operation` is the previous operator
            // We push previous operator and number into the stack.
            when (operation) {
                '+' -> {
                    stack.push(num)
                }
                '-' -> {
                    stack.push(-num)
                }
                '*' -> {
                    stack.push(stack.pop() * num)
                }
                '/' -> {
                    stack.push(stack.pop() / num)
                }
            }
            // Replace the previous operator with the current operator
            operation = c
            // Reset the number for the next number
            num = 0
        }
    }
    var sum = 0
    while (stack.isNotEmpty()) {
        sum += stack.pop()
    }
    return sum
}
```

### How it Works?
```js
// Initialization
s = "-5 + 3 * 2"
operation = '+'
num = 0
stack = []

// Encounter `-`
s = "-5 + 3 * 2"
     ^
// Enter the 2nd `if`
operation = '+'
num = 0
stack = [+0]
operation = '-' // execute `operation = c`
num = 0         // execute `num = 0` 

// Encounter `5`
s = "-5 + 3 * 2"
      ^
// Enter the 1st `if`
operation = '-', num = 5 // Update the number

// Encounter `+`, now we have push "-5" into the stack
s = "-5 + 3 * 2"
        ^
operation = '-'
num = 5
stack = [+0, -5]
operation = '+', num = 0

// Encounter `*`, push +3 into stack
stack = [+0, -5, +3]
operation = '*', num = 0

// Last iteration
s = "-5 + 3 * 2"
              ^
operation = '*', num = 2
stack = [+0, -5, +3] 
             pop +3 * 2, push 6 back

stack = [+0, -5, +6]
// Then sum up all the elements in the stack: -5 + 6 = 1
```

## Stack - 2
Or equivalently, we can use the following code to calculate the result:
1. We do really append `+` at the beginning of the string and trim the space. Now the formula becomes `+3,-2, *5, /2, +7`, which is exactly the pattern `(operator, number)`.
2. We iterate the string and parse the pattern, then push them into the stack. (For `*` and `/`, we have to calculate the result immediately with `stack.pop()`)
3. We sum up all the elements in the stack.

```kotlin
fun calculate(str: String): Int {
    val s = "+" + str.replace("\\s+".toRegex(), "")
    val stack = Stack<Int>()
    var i = 0
    while (i < s.length) {
        val c = s[i]
        if (c == '+' || c == '-') {
            // Parse the number after the operator
            var num = 0
            while (i + 1 < s.length && s[i + 1].isDigit()) {
                i++
                num = num * 10 + (s[i] - '0')
            }
            if (c == '+') {
                stack.push(num)
            } else {
                stack.push(-num)
            }
        } else if (c == '*' || c == '/') {
            // Parse the number after the operator
            var num = 0
            while (i + 1 < s.length && s[i + 1].isDigit()) {
                i++
                num = num * 10 + (s[i] - '0')
            }
            val last = stack.pop()
            if (c == '*') {
                stack.push(last * num)
            } else {
                stack.push(last / num)
            }
        }
        i++
    }
    // There is no `*` and `/` in the stack, we can sum up all the elements in the stack
    var sum = 0
    while (stack.isNotEmpty()) {
        sum += stack.pop()
    }
    return sum
}
```

## Stack - 3
Or we can split by operator and number to get the numbers and operators, then we can the apply the same idea to calculate the result.

> This approach may not work correctly if we have leading negative numbers, for example, `-5 + 3`. We could append a leading "0" to the string to avoid this issue.

```js
s = "3 - 2 * 5 / 2 + 7"
operators = s.split(number) = ["", "-", "*", "/", "+", ""] // Note that the first and last element are empty
numbers = s.split(operator) = ["3", "2", "5", "2", "7"]

// We hope to calculate in the following ways:
  0    1    2    3    4 
[ "" ,"-", "*", "/", "+", ""]
["3", "2", "5", "2", "7"]
       i ->
  3,  -2,  *5,  /2,  +7

// Then we can apply the same idea to calculate the result
```
```kotlin
fun calculate(str: String): Int {
    val s = str.replace("\\s+".toRegex(), "")
    val operators = s.split("\\d+".toRegex())
    val nums = s.split("[+\\-*/]".toRegex()).map { it.toInt() }
    val stack = Stack<Int>()
    stack.push(nums[0].toInt())
    for (i in 1 until nums.size) {
        val num = nums[i]
        val op = operators[i]
        if (op == "+") {
            stack.push(num)
        } else if (op == "-") {
            stack.push(-num)
        } else if (op == "*") {
            stack.push(stack.pop() * num)
        } else if (op == "/") {
            stack.push(stack.pop() / num)
        }
    }
    var sum = 0
    while (stack.isNotEmpty()) sum += stack.pop()
    return sum
}
```

## Reference
>  https://leetcode.cn/problems/basic-calculator-ii/solutions/91271/chai-jie-fu-za-wen-ti-shi-xian-yi-ge-wan-zheng-ji-/ (There contains the solution to [772. Basic Calculator III](https://leetcode.com/problems/basic-calculator-iii/description/))