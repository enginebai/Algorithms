# [743. Network Delay Time](https://leetcode.com/problems/network-delay-time/)

## Key Insights
1. To find the minimum time to reach all nodes, this is a single-source shortest path problem.
2. The graph is directed and weighted (positive), so we can use Dijkstra's or Bellman-Ford algorithm to find the shortest path.

## Dijkstra - 1
- It's best fit since weights are positive.
- Use a min heap to always process the adjacent node with the minimum time first.
- Maintain a time array to store the shortest known time from source to each node.

```kotlin
data class Edge(
    val node: Int,
    val time: Int
)

fun networkDelayTime(times: Array<IntArray>, n: Int, k: Int): Int {
    val graph = buildGraph(times, n)
    val time = IntArray(n + 1) { Int.MAX_VALUE } // 1-based index
    val minHeap = PriorityQueue(compareBy<Pair<Int, Int>> { it.first })
    time[k] = 0
    minHeap.add(k to 0)
    while (minHeap.isNotEmpty()) {
        val (node, t) = minHeap.poll()
        if (time[node] < t) continue
        graph[node].forEach { adj -> 
            if (time[node] + adj.time < time[adj.node]) {
                time[adj.node] = time[node] + adj.time
                minHeap.add(adj.node to time[adj.node])
            }
        }
    }
    var ans = 0
    for (node in 1..n) {
        if (time[node] == Int.MAX_VALUE) return -1
        ans = maxOf(ans, time[node])
    }
    return ans
}

private fun buildGraph(times: Array<IntArray>, n: Int): Array<HashSet<Edge>> {
    val graph = Array<HashSet<Edge>>(n + 1) { hashSetOf<Edge>() }
    for ((from, to, time) in times) {
        graph[from].add(Edge(time, to))
    }
    return graph
}
```

## Dijkstra - 2
It's a variant of Dijkstra's algorithm without changing the core Dijkstra's invariant: **the first time we visit a node pop from the heap, we have found its shortest distance**.

There are some key differences from above implementation and the "textbook" Dijkstra's algorithm:
1. Marking `visited` **on pop** instead of **on push**, this ensures us finalize a node exactly once, at **its true** shortest distance.
2. Not maintaining a `time` array (distance array):
    - We allow duplicate, it's OK to push the same node multiple times with different distance.
    - We us `visited` to discard stale entries: The **first time a node entry popped from min heap** is the shortest (positive weight); later duplicate entries are skipped by `visited` set.
3. `time` (answer) ends up being the largest time of finalized shortest distance, all nodes are popped in **non-decreasing** order of time, the last pop is the largest time.

```kotlin
fun dijkstra(times: Array<IntArray>, n: Int, k: Int): Int {
    val graph = buildGraph(times, n)
    var remainingN = n
    var time = 0
    val visited = BooleanArray(n + 1)
    val minHeap = PriorityQueue<Pair<Int, Int>>(compareBy { it.first })
    minHeap.add(0 to k)
    while (minHeap.isNotEmpty()) {
        val (t, node) = minHeap.poll()
        if (visited[node]) {
            continue
        }
        visited[node] = true
        time = maxOf(t, time)
        remainingN--
        graph[node].forEach { (adjNode, adjTime) -> 
            minHeap.add((adjTime + t) to adjNode)
        }
    }
    return if (remainingN == 0) time else -1
}
```

### Dry Run
```js
 A -- (1)--> B
 |         /
(2)       /
 |       /
 C <-- (5)
```
- We have two entries for `C`: `2` and `6`.
- We visit `C` at distance `2` first, which is the true shortest path.
- The later entry `6` is discarded because we have already visited `C` at distance `2`.
- The final answer is `2`.

```js
 A -- (1)--> B
 |         /
(5)       /
 |       /
 C <-- (2)
```

- We enqueued `C` twice: once with `5` (direct) and later with `3` (via `B`).
- We visit `C` at distance `3` first, becase we pop the shorter entry (`3 to C`) over the longer entry (`5 to C`) from the min heap.
- Mark `C` as visited.
- The later entry `5` is discarded because we have already visited `C` at distance `3`.
- The final answer is `3`.

## Shortest Path Faster Algorithm
```kotlin
fun spfa(times: Array<IntArray>, n: Int, k: Int): Int {
    val graph = buildGraph(times, n)
    val queue = ArrayDeque<Int>() // We use queue, not min heap.
    val time = IntArray(n + 1) { Int.MAX_VALUE }
    time[k] = 0
    queue.add(k)
    while (queue.isNotEmpty()) {
        val node = queue.removeFirst()
        graph[node].forEach { (adjTime, adjNode) ->
            // We relax the edge and enqueue the adjacent node, if the new distance is shorter.
            if (time[adjNode] > time[node] + adjTime) {
                time[adjNode] = time[node] + adjTime
                queue.addLast(adjNode)
            }
        }
    }
    var ans = 0
    for (node in 1..n) {
        if (time[node] == Int.MAX_VALUE) return -1
        ans = maxOf(ans, time[node])
    }
    return ans
}
```


## Bellman-Ford Algorithm

```kotlin
fun networkDelayTime(times: Array<IntArray>, n: Int, k: Int): Int {
    // Here we won't use Int.MAX_VALUE because it will break the relaxation, since Int.MAX_VALUE + any number will be Int.MIN_VALUE, it makes the result wrong.
    val infinite = Int.MAX_VALUE / 2
    val times = IntArray(n + 1) { _ -> infinite }
    times[k] = 0
    
    for (i in 1..n - 1) {
        for (edge in times) {
            val u = edge[0]
            val v = edge[1]
            val weight = edge[2]
            if (times[v] > times[u] + weight) {
                times[v] = times[u] + weight
            }
        }
    }
    
    var max = Int.MIN_VALUE
    for (vertex in 1..n) {
        val d = times[vertex]
        max = if (d > max) d else max
    }
    return if (max == infinite) -1 else max
}
```