## [797. All Paths From Source to Target](https://leetcode.com/problems/all-paths-from-source-to-target/)

### DFS (Backtracking)

1. Start at 0.
2. DFS to each neighbor.
3. When you reach `n-1`, record a copy of the path.
4. Backtrack when returning from recursion.

There are some details to pay attention to:

- We have to backtrack when existing dfs call returns, so that we can generate different paths.
- We don't need visited set here because the graph is DAG, we won't revisit the same node again.

> Please note that `[[1,2],[0],[0],[1,2]]` is not DAG!!! It's not valid test cases.

```kotlin
private val paths = mutableListOf<List<Int>>()

fun allPathsSourceTarget(graph: Array<IntArray>): List<List<Int>> {
    // We don't add node here
    dfs(graph, 0, mutableListOf<Int>())
    return paths
}

private fun dfs(graph: Array<IntArray>, node: Int, path: MutableList<Int>) {
    path.add(node)
    if (node == graph.size - 1) {
        paths.add(ArrayList(path))
        // Remember to backtracking here
        path.removeAt(path.size - 1)
        return
    }

    graph[node].forEach { adj ->
        dfs(graph, adj, path)
    }
    // Backtracking
    path.removeAt(path.size - 1)
}

```

- **Time Complexity**: `O(N * 2^N)`
  - In the worst case, the number of paths from source to target can be up to `2^(N-1)`, where `N` is the number of nodes. The worst case if a fully connected DAG.
  - In such a graph, from node `0` to node `N-1`, at each step you can choose to go to any of the next nodes, resulting in `2^(N-1)` possible paths.
  - For each path, we spend `O(N)` time to copy the path when adding to the result.
  - So, total time is `O(N * 2^N)`.
- **Space Complexity**: `O(N * 2^N)`
  - The result list can store up to `2^(N-1)` paths, each of length up to `N`.
  - The recursion stack uses up to `O(N)` space.

Or alternative way, we have different time to add node and backtracking:

```kotlin
private val paths = mutableListOf<List<Int>>()

fun allPathsSourceTarget(graph: Array<IntArray>): List<List<Int>> {
    // We add source node here
    dfs(graph, 0, mutableListOf<Int>(0))
    return paths
}

private fun dfs(graph: Array<IntArray>, node: Int, path: MutableList<Int>) {
    if (node == graph.size - 1) {
        paths.add(ArrayList(path))
        return
    }

    graph[node].forEach { adj ->
        // We add and backtrack the adjacent node here
        path.add(adj)
        dfs(graph, adj, path)
        // Backtracking
        path.removeAt(path.size - 1)
    }
}
```

### BFS

```kotlin
class Solution {
    fun allPathsSourceTarget(graph: Array<IntArray>): List<List<Int>> {
        val paths = mutableListOf<List<Int>>()
        val queue = ArrayDeque<Pair<Int, MutableList<Int>>>()
        queue.addLast(0 to mutableListOf<Int>())
        while (!queue.isEmpty()) {
            val pair = queue.removeFirst()!!
            val node = pair.first
            val path = pair.second
            path.add(node)

            if (node == graph.size - 1) {
                paths.add(path)
            } else {
                graph[node].forEach {
                    queue.addLast(it to path.toMutableList())
                }
            }
        }
        return paths
    }
}
```
