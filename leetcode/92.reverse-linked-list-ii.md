## [92. Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/)

**Idea!** We find the part to reverse and the before / after node of reverse list, reuse modified `reverseLinkedList(node)` with length to reverse, and relink the before / after node pointer to correct.

```js
1 -> 2 -> 3 -> 4 -> 5
left = 2, right = 4

// Traverse list to find the before / after pointer
before = 1
after = 5

// Reverse from left to right
reversedHead = reverseLinkedList(2 -> 3 -> 4), return 4

// Relink before and after pointer to reverse list
before -> reversedHead -> ... -> after
```

```kotlin
fun reverseBetween(head: ListNode?, left: Int, right: Int): ListNode? {
    // Pointers before and after reverse part
    var before: ListNode? = null
    var after: ListNode? = null
    // Pointer to start reverse
    var start: ListNode? = null

    // Traverse the list to locate the above pointers
    var i = 1
    var previous: ListNode? = null
    var current: ListNode? = head
    while (current != null) {
        if (i == left) {
            before = previous
            start = current
        }
        if (i == right + 1) {
            after = current
        }
        i++
        previous = current
        current = current.next
    }

    // Reverse from left to right
    var reversedHead = reverseLinkedList(start, right - left)

    // Relink the before pointer
    before?.next = reversedHead


    // Find the last node of reverse list
    var lastNode: ListNode? = reversedHead
    while (lastNode?.next != null) {
        lastNode = lastNode.next
    }
    // Relink the after pointer
    lastNode?.next = after

    // left == 1 means we reverse from start, the head will change.
    return if (left == 1) reversedHead
    else head
}

private fun reverseLinkedList(node: ListNode?, length: Int): ListNode? {
    var i = 0
    var previous: ListNode? = null
    var current: ListNode? = node
    while (current != null && i <= length) {
        val next = current.next

        current.next = previous
        previous = current
        current = next
        i++
    }
    return previous
}
```

### More Concise
For the example: `1 -> 2 -> 3 -> 4 -> 5`, left = 2, right = 4, we have to find `1 -> 2` and `4 -> 5`, and reverse between `2 -> 3 -> 4` and relink `1` to the new head of reversed list and relink the last node of reversed list to `5`.

```kotlin
fun reverseBetween(head: ListNode?, left: Int, right: Int): ListNode? {
    // We introduce sentinel for help
    val sentinel = ListNode(-1)
    sentinel.next = head
    
    // Looking for 1 -> 2
    var nodeBeforeLeft: ListNode? = sentinel
    var leftNode: ListNode? = head
    var i = 1
    while (i < left) {
        nodeBeforeLeft = leftNode
        leftNode = leftNode?.next
        i++
    }
    // Lookin for 4 -> 5
    var rightNode: ListNode? = nodeBeforeLeft
    var nodeAfterRight: ListNode? = rightNode?.next
    while (i <= right) {
        rightNode = rightNode?.next
        nodeAfterRight = rightNode?.next
        i++
    }
    
    val reverseHead = reverse(leftNode, right - left + 1)
    // Relink 1 -> reversed list
    nodeBeforeLeft?.next = reverseHead
    // Relink reversed list -> 5
    leftNode?.next = nodeAfterRight
    return sentinel.next
}

private fun reverse(start: ListNode?, count: Int): ListNode? {
    var previous: ListNode? = null
    var current: ListNode? = start
    var i = 0
    while (current != null && i < count) {
        val next = current?.next
        current?.next = previous
        previous = current
        current = next
        i++
    }
    return previous
}
```