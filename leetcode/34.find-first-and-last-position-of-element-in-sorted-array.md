## [34. Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

We search the first and last index of search separately by using modified binary search.

It stays the same as normal binary search for the cases that not found, i.e. `nums[middle] > target` or `nums[middle] < target`.

The key difference is the case that found, i.e. `nums[middle] == target`, the `middle` might be the first index or not:

```js
// To search the first index, it might be the following cases:

// 1. The first index, then the we found nothing 
// when keeping searching and idx will be our final result.
[100,..., (777) 777, 777, 777,...,999]
 left      mid                    right
           idx

// 2. Not the first or the last index
[100,..., 777, 777, (777), 777,...,999]
 left                mid           right
                     idx

// 3. The last index
[100,..., 777, 777, 777, (777),...,999]
 left                     mid      right
                          idx
```

For the above three possible cases, the first index will always be the left part or the current `mid`.

So we update the result index (`idx`) first and keep searching the left part (updating `right`), if we find again, it means there exist an index prior to the current result.


```kotlin
fun searchRange(nums: IntArray, target: Int): IntArray {
    return intArrayOf(
        searchFirstIndex(nums, target),
        searchLastIndex(nums, target)
    )   
}

private fun searchFirstIndex(nums: IntArray, target: Int): Int {
    var index = -1
    var left = 0
    var right = nums.size - 1
    while (left <= right) {
        val middle = left + (right - left) / 2
        // We update the index first
        if (nums[middle] == target) index = middle
        // Then keep searching if there exists target that index < current result
        if (nums[middle] >= target) {
            right = middle - 1
        } else {
            left = middle + 1
        }
    }
    return index
}

private fun searchLastIndex(nums: IntArray, target: Int): Int {
    var index = -1
    var left = 0
    var right = nums.size - 1
    while (left <= right) {
        val middle = left + (right - left) / 2
        if (nums[middle] == target) index = middle
        if (nums[middle] <= target) {
            left = middle + 1
        } else {
            right = middle - 1
        }
        
    }
    return index
}
```

> Nice explanation: https://medium.com/@lindingchi/binary-search-%E9%82%A3%E4%BA%9B%E8%97%8F%E5%9C%A8%E7%B4%B0%E7%AF%80%E8%A3%A1%E7%9A%84%E9%AD%94%E9%AC%BC-%E4%B8%89-%E5%BE%88%E5%A4%9A%E7%9B%B8%E5%90%8C%E7%9A%84%E6%83%85%E5%A2%83-c2215d1b9dc7

如果我們要找 `target=8` 的第一個位置，假設我們有三個 `8`，那麼 `middle` 可能會落在三個位置，那麼我們要怎麼縮限下一個搜尋的範圍：

```js
8 8 8
  M

8 8 8
    M

// 這兩種情境第一個位置可能是當前 M 或者他的左邊，所以當 target <= nums[middle]，我們要搜尋左半邊。

8 8 8
M

// 第一個位置就是在 M 位置，這樣套用上述邏輯，最後 L 和 R 和 M 都會走到這個 8 的左邊位置，在執行一次程式，L 就會跑到第一個 8 然後跳出迴圈。

```

```kotlin
// Implemented based on the above explanation post!!

fun searchRange(nums: IntArray, target: Int): IntArray {
    return intArrayOf(
        findStartingPosition(nums, target),
        findEndingPosition(nums, target)
    )
}

private fun findStartingPosition(nums: IntArray, target: Int): Int {
    var found = false
    var left = 0
    var right = nums.size - 1
    while (left <= right) {
        val middle = left + (right - left) / 2
        if (nums[middle] == target) found = true
        if (nums[middle] >= target) {
            right = middle - 1
        } else {
            left = middle + 1
        }
    }
    return if (found) left else - 1
}

private fun findEndingPosition(nums: IntArray, target: Int): Int {
    var found = false
    var left = 0
    var right = nums.size - 1
    while (left <= right) {
        val middle = left + (right - left) / 2
        if (nums[middle] == target) found = true
        if (target >= nums[middle]) {
            left = middle + 1
        } else {
            right = middle - 1
        }
    }
    return if (found) right else - 1
}
```