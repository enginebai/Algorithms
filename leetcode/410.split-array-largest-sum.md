# [410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/description/)

```js
nums = [7, 2, 5, 10, 8]
k = 2

7 | 2 + 5 + 10 + 8 = 7 | 25     25
7 + 2 | 5 + 10 + 8 = 9 | 23     23
7 + 2 + 5 | 10 + 8 = 14 | 18    18
7 + 2 + 5 + 10 | 8 = 24 | 8     24
```

* The minimum value of the largest sum is the maximum value in the input array. Because we can split the array into `k == n` subarray. It's `[7 | 2 | 5 | 10 | 8]` = `10`.
* The maximum value of the largest sum is the sum of the input array. Because we can split the array into `k == 1` subarrays (only one subarray), and the largest sum is the sum of the whole array. It's `[7 + 2 + 5 + 10 + 8]` = `32`.

```kotlin
fun splitArray(nums: IntArray, k: Int): Int {0
    var left = 0
    var right = 0
    for (n in nums) {
        left = maxOf(left, n)
        right += n
    }

    while (left <= right) {
        val middle = left + (right - left) / 2
        if (splitCount(nums, middle) <= k) {
            right = middle - 1
        } else {
            left = middle + 1
        }
    }
    return left
}

/**
 * Given a value, check how many subarray we can split the input array into so that
 * the sum of each subarray <= value.
 */
private fun splitCount(nums: IntArray, value: Int): Int {
    var split = 1
    var sum = 0
    for (n in nums) {
        sum += n
        if (sum > value) {
            split++
            sum = n
        }
    }
    return split
}

/**
 * Check the split count of the array so that the sum of each subarray <= value.
 */
fun canSplit(nums: IntArray, k: Int, value: Int): Boolean {
    // [A, B, C, D]
    // A + B <= value
    // A + B + C > value
    // A + B | C, D

    // check how many subarray which sum <= value == k?
    var split = 0
    var i = 0
    while (i < nums.size) {
        var j = i
        var sum = 0
        while (j < nums.size && sum + nums[j] <= value) {
            sum += nums[j]
            j++
        }
        split++
        i = j
    }
    return split <= k
}
```