## [63. Unique Paths II](https://leetcode.com/problems/unique-paths-ii/)

### Bottom-Up DP
Pay attention on the base case `[0, 1, 0, 0, 0]`, if there is one obstacle in the first row or column, then the following item after that obstacle will be unreachable (path will be zero), so the `dp` will be `[1, 0, 0, 0, 0]`.

```kotlin 
fun uniquePathsWithObstacles(obstacleGrid: Array<IntArray>): Int {
    val m = obstacleGrid.size
    val n = obstacleGrid[0].size
    if (obstacleGrid[0][0] == 1 || obstacleGrid[m - 1][n - 1] == 1) return 0       
    
    val dp = Array(m) { _ -> IntArray(n) }
    var obstacleBorder = false

    // Base cases:
    // For obstacleGrid = [0, 1, 0, 0], it initializes the dp to [1, 0, 0, 0] all the right and down side will be 0 if encounter one obstacle.
    for (i in 0 until m) {
        if (obstacleGrid[i][0] == 1) {
            obstacleBorder = true
        }
        if (obstacleBorder) {
            dp[i][0] = 0
        } else {
            dp[i][0] = 1
        }
    }
    // Alternative:
    // for (i in 1 until m) {
    //     obstacleGrid[i][0] = (obstacleGrid[i][0] == 0 && obstacleGrid[i - 1][0] == 1) ? 1 : 0;
    // }

    obstacleBorder = false
    for (i in 0 until n) {
        if (obstacleGrid[0][i] == 1) {
            obstacleBorder = true
        }
        
        if (obstacleBorder) {
            dp[0][i] = 0
        } else {
            dp[0][i] = 1
        }
    }
    
    // Start iterating the DP.
    for (i in 1 until m) {
        for (j in 1 until n) {
            if (obstacleGrid[i][j] == 1) dp[i][j] = 0 
            else {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
            }
        }
    }
    return dp[m - 1][n - 1]
}
```

* **Time Complexity**: `O(m * n)`
* **Space Complexity**: `O(m * n)`

### Bottom-Up DP (Space Optimization) 
`dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`

```js
               dp[i - 1][j]
                     |
                     v
dp[i][j - 1] ->  dp[i][j]
```

We can reduce the 2D array into 1D array (for `dp[i - 1][j]`) with `left` (for `dp[i][j - 1]`) value, we can just use `dp[j] = d[j] + dp[j - 1]`.

```js
dp[0, 1, ..., j - 1, j]
   |  |         |
   v  v         v
dp[0, 1, ..., j - 1  ?
```

When the time we calcluate `dp[j]`, `dp[j - 1]` will be updated and it becomes `left` value, so we can get rid of `left`, just use `dp[j - 1]`.

```kotlin
fun uniquePathsWithObstacles(grid: Array<IntArray>): Int {
    val m = grid.size
    val n = grid[0].size
    if (grid[0][0] == 1 || grid[m - 1][n - 1] == 1) return 0
    
    val dp = IntArray(n)
    
    dp[0] = 1
    var meetObstacle = false
    for (j in 1 until n) {
        if (meetObstacle) dp[j] = 0
        else {
            if (grid[0][j] == 1) {
                dp[j] = 0
                meetObstacle = true
            } else {
                dp[j] = 1
            }
        }
    }
    
    meetObstacle = false
    for (i in 1 until m) {
        for (j in 0 until n) {
            if (j == 0) {
                if (meetObstacle) dp[j] = 0
                else {
                    if (grid[i][j] == 1) {
                        dp[j] = 0
                        meetObstacle = true
                    } else {
                        dp[j] = 1
                    }
                }
            } else {
                if (grid[i][j] == 1) dp[j] = 0
                else dp[j] = dp[j] + dp[j - 1]               
            }
        }
    }
    return dp[n - 1]
}
```

* **Time Complexity**: `O(m * n)`
* **Space Complexity**: `O(n)`