## [207. Course Schedule](https://leetcode.com/problems/course-schedule/)

### DFS
The problem is equivalent to detect a cycle in a directed graph. If there exists a cycle, then we can't find the topological sort.

```kotlin
enum class VisitState { NOT_VISIT, VISITED, FINISHED }

class Solution {
    
    private val topologicalSort = Stack<Int>()
    private var valid = true
    
    fun canFinish(numCourses: Int, prerequisites: Array<IntArray>): Boolean {
        val graph = mutableMapOf<Int, MutableSet<Int>>()
        for (n in 0 until numCourses) {
            graph[n] = mutableSetOf<Int>()
        }
        prerequisites.forEach { pair -> 
            graph[pair[1]]!!.add(pair[0])
        }
        
        val visitState = Array<VisitState>(numCourses) { _ -> VisitState.NOT_VISIT }

        // We have to iterate from 0 to `numCourses - 1`, not all vertices from the graph!!
        for (n in 0 until numCourses) {
            if (visitState[n] == VisitState.NOT_VISIT) {
                dfs(graph, n, visitState)
            }
        }
        return valid
    }
    
    private fun dfs(graph: Map<Int, Set<Int>>, source: Int, visitState: Array<VisitState>) {
        visitState[source] = VisitState.VISITED
        graph[source]!!.forEach { x -> 
            if (visitState[x] == VisitState.NOT_VISIT) {
                dfs(graph, x, visitState)
                // Remember to check if valid here!!
                if (!valid) return
            } else if (visitState[x] == VisitState.VISITED) {
                valid = false
                return
            }
        }
        visitState[source] = VisitState.FINISHED
        topologicalSort.push(source)
    }
}
```

* **Time Complexity**: `O(m + n)`, `m` is the number of courses, `n` is the number of prerequisites.
* **Space Complexity**: `O(m + n)`, we build a adjacent list that takes `O(m + n)`, and enque all courses that takes `O(n)`.

### BSF
BFS approach uses the indegrees of every vertex, for a course (vertex), the indegrees represents how many prerequisites we have to take before so that we can finish the current one.

For example, the `prerequisites` is `[[2, 0], [2, 1]]`, that means that I have to finish course `0` and `1` so that I can finish `2`, that can be represented in graph like this:

```js
0 -> 2
1 -> 2
```

So course (vertex) `2` has 2 indegree edges, and the number of indegrees is `2`.

To solve this problem, we build a graph with indegree array for every courses (vertices), and enqueue course if I finish all its prerequisites, and count how many courses did I finished.

```kotlin
fun canFinish(numCourses: Int, prerequisites: Array<IntArray>): Boolean {
    val edges = Array<MutableList<Int>>(numCourses) { _ -> mutableListOf<Int>() }

    val inDegrees = IntArray(numCourses)
    for (p in prerequisites) {
        val before = p[1]
        val after = p[0]
        // p[1] -> p[0]
        edges[before].add(after)
        inDegrees[after]++
    }

    // Queue enques all the course that we can study now. (no or finished all prerequisites)
    val queue = ArrayDeque<Int>()
    for (i in 0 until numCourses) {
        // Study all the courses without any prerequisites.
        if (inDegrees[i] == 0) queue.addLast(i)
    }

    var studiedCourses = 0
    while (queue.isNotEmpty()) {
        val course = queue.removeFirst()
        studiedCourses++

        // Find all courses after the current course
        edges[course].forEach { afterCourse ->
            inDegrees[afterCourse]--

            // If all prerequiistes are finished, then I can study this after course.
            if (inDegrees[afterCourse] == 0) {
                queue.addLast(afterCourse)
            }
        }
    }
    return studiedCourses == numCourses
}
```

* **Time Complexity**: As same as DFS.
* **Space Complexity**: As same as DFS.

### Clarification Questions
1. Are all the prerequisites pair unique?
2. What if `prerequisites` is empty? (but `numCourses` is 1 or greater than 1)
3. Do all the prerequisite pairs cover all courses from 0 to `numCourses - 1`.