## [62. Unique Paths](https://leetcode.com/problems/unique-paths/)

### Top-Down Recursion
```kotlin
// 1-based index
fun uniquePaths(m: Int, n: Int): Int {
    if (m == 1 || n == 1) return 1
    return uniquePaths(m - 1, n) + uniquePaths(m, n - 1)
}
```

### Top-Down DP
The robic can only move right and down, when it arrived at a point, it either comes from left or above, let the `dp[i][j]` represent the unique path when arriving at `(i, j)`, the value comes from left `dp[i][j - 1]` and above `dp[i - 1][j]`, and base cases will be `dp[i][0] = 1` and `dp[0][j] = 1` (only one direction can go)

```kotlin
fun uniquePaths(m: Int, n: Int): Int {
    val dp = Array(m) { IntArray(n) { -1 } }
    return helper(m - 1, n - 1, dp)
}

private fun helper(m: Int, n: Int, dp: Array<IntArray>): Int {
    if (m == 0 || n == 0) return 1
    if (dp[m][n] != -1) return dp[m][n]
    dp[m][n] = helper(m - 1, n, dp) + helper(m, n - 1, dp)
    return dp[m][n]
}
```
* **Time Complexity**: `O(m * n)`
* **Space Complexity**: `O(m * n)`

### Bottom-Up DP
```js
          (x - 1, y)
               |
               v
(x, y - 1) -> (x, y)
```

```kotlin
fun uniquePaths(m: Int, n: Int): Int {
    val dp = Array(m) { IntArray(n) }
    dp[0][0] = 1
    for (i in 0 until m) {
        for (j in 0 until n) {
            dp[i][j] = if (i == 0 || j == 0) 1
            else dp[i - 1][j] + dp[i][j - 1]
        }
    }
    return dp[m - 1][n - 1]
}
```
* **Time Complexity**: `O(m * n)`
* **Space Complexity**: `O(m * n)`

### Bottom-Up DP (Space Optimization)
`dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`. The row depends on the previous row, so we can optimize the space by using a 1D array.
```kotlin
fun uniquePaths(m: Int, n: Int): Int {
    val dp = IntArray(n) { 1 }
    for (i in 1 until m) {
        for (j in 1 until n) {
            dp[j] += dp[j - 1]
        }
    }
    return dp[n - 1]
}
```

* **Time Complexity**: `O(m * n)`
* **Space Complexity**: `O(n)`

### DFS (TLE)
```kotlin
fun uniquePaths(m: Int, n: Int): Int {
    return dfs(0, 0, m, n)
}

private fun dfs(x: Int, y: Int, m: Int, n: Int): Int {
    if (x == m - 1 && y == n - 1) return 1
    return dfs(x + 1, y, m, n) + dfs(x, y + 1, m, n)
}
```
