## [141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)

```kotlin
fun hasCycle(head: ListNode?): Boolean {
    val seenNode = hashSetOf<ListNode>()
    var node = head
    while (node != null) {
        if (seenNode.contains(node)) {
            return true
        }
        seenNode.add(node)
        node = node.next
    }
    return false
}
```

We can use two pointers approach to solve this with `O(1)` space:
1. Slow pointer goes 1 step, fast pointer goes 2 step.
2. Traverse the linked list.
3. The two pointer will meet at the same node if there is cycle.

```kotlin
fun hasCycle(head: ListNode?): Boolean {
    var slow: ListNode? = head
    var fast: ListNode? = head
    while (fast != null && fast.next != null) {
        show = show?.next
        fast = fast?.next?.next
        if (fast == slow) return true
    }
    return false
}
```

For two pointers approach, there are some equivalent implementations:

> **Important**!! But we will choose above impelementation since it will affect the idea and result of [142. Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/).

```kotlin
/// Slow 1, fast 2
//	    **Slow 2, fast 4
// Slow 2, fast 4
//	    **Slow 3, fast 3
// Slow 3, fast 3
//true
fun hasCycle2(head: ListNode?): Boolean {
    var slow: ListNode? = head
    var fast: ListNode? = head?.next
    while (slow != null) {
        if (slow == fast) return true
        slow = slow.next
        fast = fast?.next?.next
    }
    return false
}
```
