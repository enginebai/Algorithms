## [692. Top K Frequent Words](https://leetcode.com/problems/top-k-frequent-words/)

### Sorting
```kotlin
fun topKFrequent(words: Array<String>, k: Int): List<String> {
    if (words.size == 1) return listOf(words[0])

    val frequencyMap = hashMapOf<String, Int>()
    for (word in words) {
        if (frequencyMap.containsKey(word)) {
            frequencyMap[word] = frequencyMap[word]!! + 1
        } else {
            frequencyMap[word] = 1
        }
    }
    val frequencyList = frequencyMap.toList().sortedWith(Comparator<Pair<String, Int>> { p1, p2 ->
        val frequency1 = p1.second
        val frequency2 = p2.second
        if (frequency1 != frequency2) {
            // Higher frequency first
            frequency2 - frequency1
        } else {
            // Sort string lexicographically
            p1.first.compareTo(p2.first)
        }
    })

    return frequencyList.map { it.first }.subList(0, frequencyList.size.coerceAtMost(k))
}
```

### Heap
```kotlin
fun topKFrequent(words: Array<String>, k: Int): List<String> {
    if (words.size == 1) return listOf(words[0])

    val frequencyMap = hashMapOf<String, Int>()
    for (word in words) {
        if (frequencyMap.containsKey(word)) {
            frequencyMap[word] = frequencyMap[word]!! + 1
        } else {
            frequencyMap[word] = 1
        }
    }
}
```

### Bucket Sort
```kotlin
fun topKFrequent(words: Array<String>, k: Int): List<String> {
    if (words.size == 1) return listOf(words[0])
    
    val frequencyMap = hashMapOf<String, Int>()
    for (word in words) {
        if (frequencyMap.containsKey(word)) {
            frequencyMap[word] = frequencyMap[word]!! + 1
        } else {
            frequencyMap[word] = 1
        }
    }
    
    val buckets = MutableList<MutableList<String>>(words.size + 1) { _ -> mutableListOf<String>() }
    frequencyMap.forEach { word, frequency -> 
        buckets[frequency].add(word)
    }
    val results = mutableListOf<String>()
    for (i in buckets.size - 1 downTo 0) {
        if (results.size < k && buckets[i].isNotEmpty()) {
            val list = buckets[i]
            Collections.sort(list, Comparator { s1, s2 -> 
                // Compare the strings lexicographically.
                // "a".compareTo("b") = -1, a < b
                // "a".compareTo("ab") = -1, a < ab
                s1.compareTo(s2)
            })
            for (word in list) {
                if (results.size < k) results.add(word)
            }
        }
    }
    return results
}
```

### Failed Cases
```js
["a", "aa", "aaa"]
1

["a", "bc", "c", "a", "bc", "c"]
2
``