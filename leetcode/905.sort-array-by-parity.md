## [905. Sort Array By Parity](https://leetcode.com/problems/sort-array-by-parity/)

### Two Pointers with Extra Space
We just create an extra space to store the even add odd numbers at different side of the array.

```kotlin
fun sortArrayByParity(nums: IntArray): IntArray {
    val results = IntArray(nums.size)
    var evenIndex = 0
    var oddIndex = nums.size - 1
    for (i in 0 until nums.size) {
        if (nums[i] % 2 == 0) {
            results[evenIndex] = nums[i]
            evenIndex++
        } else {
            results[oddIndex] = nums[i]
            oddIndex--
        }
    }
    return results
}
```

* **Time Complexity**: `O(n)` for only one for-loop.
* **Space Complexity**: `O(n)` for extra result array.

### Two Pointers by Swapping Even Number to the Left Part
**Idea!!** Check even number and swap to the left part. We keep the even index, and try to place to the left side of the array by swapping when we meet even number.

```js
[1, 2, 4, 3]
 E
    R
[2, 1, 4, 3]
    E
       R
[2, 4, 1, 3]
       E
          R
```

```kotlin
fun sortArrayByParity(nums: IntArray): IntArray {
    var readIndex = 0
    var evenIndex = 0
    while (readIndex < nums.size) {
        if (nums[readIndex] % 2 == 0) {
            swap(nums, readIndex, evenIndex)
            evenIndex++
        }
        readIndex++
    }
    return nums
}

private fun swap(nums: IntArray, left: Int, right: Int) {
    val temp = nums[left]
    nums[left] = nums[right]
    nums[right] = temp
}
```

* **Time Complexity**: `O(n)` for only one for-loop.
* **Space Complexity**: `O(1)` no extra space.

### Two Pointers by Swapping Odd Number to the Right Part
**Idea!!** Swap odd number to the right part.

1. Define two pointer to start and end of the array.
2. Check odd number from the start and swap with the element number at the end index.
3. We might meet odd number after swapping, so we keep checking odd number and swap until even number meets.

```js
[2, 4, 1, ... 8, 3, 5]
       R            O   // swap 1, 5
       5, ... 8, 3, 1   // but 5 is odd, so we keep swapping
       R         O
       3, ... 8, 5, 1   // but 3 is odd, so we keep swapping
       R      O
       8, ... 3, 5, 1   // 8 is even, so we stop swapping
```

```kotlin
fun sortArrayByParity(nums: IntArray): IntArray {
    var readIndex = 0
    var oddIndex = nums.size -1
    while (readIndex <= oddIndex) {
        if (nums[readIndex] % 2 != 0) {
            swap(nums, readIndex, oddIndex)
            oddIndex--
        } else {
            readIndex++
        }

        // Or we can skip the odd number at the end.
        // if (nums[readIndex] % 2 != 0) {
        //     if (nums[oddIndex] % 2 == 0) {
        //         swap(nums, readIndex, oddIndex)
        //     }
        //     oddIndex--
        // } else {
        //     readIndex++
        // }
    }
    return nums       
}

private fun swap(nums: IntArray, left: Int, right: Int) {
    val temp = nums[left]
    nums[left] = nums[right]
    nums[right] = temp
}
```

* **Time Complexity**: `O(n)` for only one for-loop.
* **Space Complexity**: `O(1)` no extra space.