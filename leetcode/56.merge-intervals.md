## [56. Merge Intervals](https://leetcode.com/problems/merge-intervals/)

The idea is that we sort the array first by the `start`, so that we can iterate every interval and merge one by one:
* We assign the first interval to `merged`.
* For each interval, we check if it's overlapped with `merged`, if so, we merge them.
* If not, we add the `merged` to the result and assign the current interval to `merged`.

```js
// Sort by start
[[1, 3], [2, 6], [8, 10], [15, 18]]
 merged  toMerge
         [1, 6], [8, 10], [15, 18]]
                 toMerge
                 [1, 10], [15, 18]]
                          toMerge

// After merging
[1, 10], [15, 18]
```

To merge the two intervals, we just need to keep the smaller `start` and the larger `end`, that is `min(merged[0], toMerge[0]), max(merged[1], toMerge[1])`

```js
// 1. Fully Overlapped: just keep the longer interval [1, 4]
 1  2  3  4  5  6  7  8
 |--------|
    |--|

// Merged:
 1--------4

// 2. Partially Overlapped: merged, [1, 5]
 1  2  3  4  5  6  7  8
 |--------|
       |-----|

// Merged:
 1-----------5

// 3. Adjacent: extended, [1, 5]
 1  2  3  4  5  6  7  8
 |--------|
          |--|

// Merged:
 1-----------5

// 4. No Overlap: keep both, [1, 4][6, 8]
[1      4]   [6   8]
```

```kotlin
fun merge(intervals: Array<IntArray>): Array<IntArray> {
    Arrays.sort(intervals) { i1, i2 -> i1[0] - i2[0] }

    val results = mutableListOf<IntArray>()
    var merged = intervals[0]
    // Remember to add the merged interval to results first (or later)
    results.add(merged)
    for (i in 1 until intervals.size) {
        val toMerge = intervals[i]
        if (isOverlapped(merged, toMerge)) {
            merged[0] = minOf(merged[0], toMerge[0])
            merged[1] = maxOf(merged[1], toMerge[1])
        } else {
            // not overlap
            merged = toMerge
            results.add(merged)
        }
    }
    return results.toTypedArray()
}

// Or we can add `merged` later:
fun merge(intervals: Array<IntArray>): Array<IntArray> {
    Arrays.sort(intervals) { i1, i2 -> i1[0] - i2[0] }
    var merged = intervals[0]
    val results = mutableListOf<IntArray>()
    for (i in 1 until intervals.size) {
        val toMerge = intervals[i]

        if (isOverlapped(merged, toMerge)) {
            merged[0] = minOf(merged[0], toMerge[0])
            merged[1] = maxOf(merged[1], toMerge[1])
        } else {
            results.add(merged)
            merged = toMerge
        }
    }
    results.add(merged)
    return results.toTypedArray()
}
```

* **Time Complexity**: `O(n lg n)` for sorting, `O(n)` to merge, total time is `O(n lg n)`.
* **Space Complexity**: `O(lg n)` for sorting.