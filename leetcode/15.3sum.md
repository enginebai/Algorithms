## [15. 3Sum](https://leetcode.com/problems/3sum/)

### Two Pointers
The idea is similar to [167. Two Sum II - Input Array Is Sorted](../leetcode/167.two-sum-ii-input-array-is-sorted.md), we iterate the first number, then use two pointers to find the sum of the remaining two numbers.

The problem here is how to avoid duplicate triplets? We just ensure the second number is greater than the first number, and the third number so on. We iterate `(a, b, c)` where `a <= b <= c`, then there is no way to iterate `(b, a, c)` or `(c, a, b)` ...etc. So we **sort** the array first.

Sort array `[-1, 0, 1, 2, -1, -4]` becomes `[-4, -1, -1, 0, 1, 2]`, then we can fix the `1st` number one by one, and use two points to find the `2nd` + `3rd` number that make the three sum = 0:

> You can skip this part if you are familiar with [167. Two Sum II - Input Array Is Sorted](../leetcode/167.two-sum-ii-input-array-is-sorted.md).

```
[-4, -1, -1, 0, 1, 2]
  i   L ->      <- R
```
The first number sets to `-4`, the target number will be `4`, then we apply two points approach to the subarray `[-1, -1, 0, 1, 2]` to find the `2nd` + `3rd` numbers, when left + right < target, we move forward left pointer, otherwise, move backward right pointer. (Same idea as [167. Two Sum II - Input Array Is Sorted](../leetcode/167.two-sum-ii-input-array-is-sorted.md))

```
[-4, -1, -1, 0, 1, 2]
  i   L         R
```

And we have to avoid the duplicate triplets, so we will skip and move forward/backward pointers for the three numbers.

```kotlin
fun threeSum(nums: IntArray): List<List<Int>> {
    nums.sort()
    val results = mutableListOf<List<Int>>()
    for (i in 0 until nums.size) {
        val current = nums[i]

        // For sorted array, when we encounter the first positive, that means the number after will be positive as well. We can't find sum == 0 for two numbers are positive anymore.
        if (current > 0) break

        // Skip duplicate for the first number
        if (i > 0 && nums[i] == nums[i - 1]) continue

        var left = i + 1
        var right = nums.size - 1
        val target = -current
        while (left < right) {
            if (nums[left] + nums[right] == target) {
                results.add(listOf(current, nums[left], nums[right]))

                // Prune the duplicate numbers
                do {
                    left++
                } while (left < nums.size && nums[left] == nums[left - 1])
                do {
                    right--
                } while (right >= 0 && nums[right] == nums[right + 1])
            } 
            
            // Two sum is less than target, means negative number is too negative, move forward left pointer to "smaller" negative number
            else if (nums[left] + nums[right] < target) {
                do {
                    left++
                } while (left < nums.size && nums[left] == nums[left - 1])
            } else {
                do {
                    right--
                } while (right >= 0 && nums[right] == nums[right + 1])
            }
        }
    }
    return results
}
```

* **Time Complexity**: `O(n^2)` for two iterations.
* **Space Complexity**: `O(lg n)` for sorting.