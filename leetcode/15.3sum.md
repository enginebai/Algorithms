## [15. 3Sum](https://leetcode.com/problems/3sum/)

### Two Pointers
> The reason why to sort first, the way to avoid duplicate and why two pointers approach helps, you can take a [nice explanation](https://leetcode.cn/problems/3sum/solution/san-shu-zhi-he-by-leetcode-solution/)!!

The array `[-1, 0, 1, 2, -1, -4]` can be sorted at first, it will become `[-4, -1, -1, 0, 1, 2]`, then we can fix the `1st` number one by one, and use two points to find the `2nd` + `3rd` number that make the three sum = 0:

```
[-4, -1, -1, 0, 1, 2]
  i   L->        <-R
```
The first number sets to `-4`, the target number will be `4`, then we apply two points approach to the subarray `[-1, -1, 0, 1, 2]` to find the `2nd` + `3rd` numbers, when left + right < target, we move forward left pointer, otherwise, move backward right pointer.

And we have to avoid the duplicate triplets, so we will skip and move forward/backward pointers or the `1st` numbers if the number is the same.

```kotlin
fun threeSum(nums: IntArray): List<List<Int>> {
    nums.sort()
    val results = mutableListOf<List<Int>>()
    for (i in 0 until nums.size) {
        val current = nums[i]

        // For sorted array, when we encounter the first positive, that means the number after will be positive as well. We can't find sum == 0 for two numbers are positive anymore.
        if (current > 0) break

        // Skip duplicate for the first number
        if (i > 0 && nums[i] == nums[i - 1]) continue

        var left = i + 1
        var right = nums.size - 1
        val target = -current
        while (left < right) {
            if (nums[left] + nums[right] == target) {
                results.add(listOf(current, nums[left], nums[right]))

                // Prune the duplicate numbers
                do {
                    left++
                } while (left < nums.size && nums[left] == nums[left - 1])
                do {
                    right--
                } while (right >= 0 && nums[right] == nums[right + 1])
            } 
            
            // Two sum is less than target, means negative number is too negative, move forward left pointer to "smaller" negative number
            else if (nums[left] + nums[right] < target) {
                do {
                    left++
                } while (left < nums.size && nums[left] == nums[left - 1])
            } else {
                do {
                    right--
                } while (right >= 0 && nums[right] == nums[right + 1])
            }
        }
    }
    return results
}
```

* **Time Complexity**: `O(n^2)`.
* **Space Complexity**: `O(n^2)`.