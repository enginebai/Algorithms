## [33. Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)

We have to solve with `O(lg n)` time complexity, so we will start from binary search, but we have to decide the left or right part to search for next round, and since the array might be rotated, it won't be sorted for both left and right part, we have modify some logic here:

In each round of binary search, we will split the `array[start..end]` into two parts: `[start..middle - 1]` and  `[middle + 1..end]` and the key point here is that **one of the two parts will be sorted**, we have to find the sorted part (the starting value <= the ending value of that part) and we have to check if the target is in that sorted part, if yes, just search that part, otherwise, search another part.

For example, nums = `[6, 7, 0, 1, 2, 5]`, target = 3:
* The `middle` = 1, left part = `[6, 7, 0]`, right part = `[2, 5]`.
* We check which part is sorted by checking if the first element <= the last element. The right part is sorted.
* Then we check if `target` in the range of sorted part, `3 in 2..5`, so we search `[2, 5]` part.
* Otherwise, we search another part.

```kotlin
fun search(nums: IntArray, target: Int): Int {
    var left = 0
    var right = nums.size - 1
    while (left <= right) {
        val middle = left + (right - left) / 2
        if (target == nums[middle]) return middle
        else if (nums[left] <= nums[middle]) {
            if (target in nums[left]..nums[middle])
                right = middle - 1
            else 
                left = middle + 1
        } else {
            if (target in nums[middle]..nums[right])
                left = middle + 1
            else
                right = middle - 1
        }
    }
    return -1
}
```