# [543. Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/)

## Test Cases
### Normal Cases
```
Input: 
        1
      /   \
     2     3
   /  \ 
  5    4
      /
     6

Output: 4, (6-4-2-1-3)
```
### Edge / Corner Cases
* The diameter does not pass the root node.
```
Input: 
        1
      /   \
     2     3
   /  \ 
  5    4
   \     \
    5     6
     \     \
      7     8   
     
Output: 6 (7-5-2-4-6-8)
```

## Postorder
The diameter of a given tree is the **maximum depth of left subtree + right subtree**. The key idea to solve this problem is to traverse every node, and find the maximum diameter of root itself + left + right subtree for each node. 

```js
        root            dfs(root)
       /    \          / +1      \ +1
     left  right    dfs(left)   dfs(right)
```
We can use postorder traversal to find the diameter of the binary tree. The path may not pass the `root` node, so we have a global variable to store the maximum diameter and create a dedicated function to calculate the diameter of the tree. 

```kotlin
private var result = 0
fun diameterOfBinaryTree(root: TreeNode?): Int {
    dfs(root)
    return result
}

// The function returns the maximum length that passes the root node.
private fun dfs(root: TreeNode?): Int {
    if (root == null) return 0

    // The root might not have left or right child, if not, there is no edge and we can't +1
    val left = if (root.left != null) 1 + dfs(root.left) else 0
    val right = if (root.right != null) 1 + dfs(root.right) else 0

    // We update the global maximum diameter during the traversal
    result = maxOf(result, left + right)
    return maxOf(left, right)
}
```
* **Time Complexity**: `O(n)`, where `n` is the number of nodes in the binary tree.
* **Space Complexity**: `O(h)`.

----
Or equivalently, we can implement in this way (which is more common from discussion):

Define `dfs(root)` to represent the maximum length that includes the current root. If the `root` is empty, then it returns 0, otherwise, it returns the maximum length that includes the current root, even if **it's a leaf node, which contributes to one edge.**

```js
    /    or   \
  leaf       right

dfs(leaf) = 1 // 1 edge from the leaf to its parent
```

In the `dfs(root)`, we calculate the length of the left and right subtree first (postorder), and update the global maximum diameter, then return value is the maximum length that includes the current root. 

![](../media/543.diameter-of-binary-tree-2.png)

```js
dfs(left)

    /
  left
  /  \
...   ...

dfs(right)

    \
    right
    /  \
  ...   ...

dfs(root) = max(dfs(left), dfs(right)) + 1

          / // +1 for this edge
        root
       /    \
    left   right
    /  \    /  \
 ...  ... ...  ...
```

```kotlin
private var answer = 0

fun diameterOfBinaryTree(root: TreeNode?): Int {
    dfs(root)
    return answer
}

private fun dfs(root: TreeNode?): Int {
    if (root == null) return 0
    val left = dfs(root.left)
    val right = dfs(root.right)

    answer = maxOf(answer, left + right)
    return maxOf(left, right) + 1 // +1 for the edge between root and it parent
}
```

### Dry Run
* Empty tree:
```js
dfs(null) = 0
answer = 0
```

* Single node:
```js
dfs(A) = 1 // Most confusing case, but if you take a look at the next case, you will understand.
    dfs(A.left=null) = 0
    dfs(A.right=null) = 0
    answer = maxOf(0, 0 + 0) = 0
    return max(0, 0) + 1 = 1
answer = 0
```
* Root with one child:
```js   
    A    A
   /      \
  B        B
dfs(A)
    dfs(A.left=B) = 1 // Which is the same as the previous case, it contirbute to one edge between A and B. 
        dfs(B.left=null) = 0
        dfs(B.right=null) = 0
        answer = maxOf(0, 0 + 0) = 0
        return max(0, 0) + 1 = 1

    dfs(A.right=null) = 0
    answer = maxOf(0, 1 + 0) = 1
    return max(1, 0) + 1 = 2
answer = 1
```
* Root with two children:

```js
    A
   / \
  B   C

dfs(A)
    dfs(A.left=B) = 1
        dfs(B.left=null) = 0
        dfs(B.right=null) = 0
        answer = maxOf(0, 0 + 0) = 0
        return max(0, 0) + 1 = 1

    dfs(A.right=C) = 1
        dfs(C.left=null) = 0
        dfs(C.right=null) = 0
        answer = maxOf(0, 0 + 0) = 0
        return max(0, 0) + 1 = 1

    answer = maxOf(0, 1 + 1) = 2
    return max(1, 1) + 1 = 2
```
![](../media/543.diameter-of-binary-tree-1.png)

### Some Explanations
* The diameter of a given tree is **the maximum depth of the left side of the tree, plus the maximum depth of the right side of the tree**. We can write the following pseudocode:
```python
# depth() is a pseudocode function we have to implement later
diameter = depth(root.left) + depth(root.right)
```
* To calculate the height rather than the depth, which the just the representation of edges as required:
```java
class Solution {
    private int answer = 0;
    public int diameterOfBinaryTree(TreeNode root) {
        height(root);
        return answer;
    }
    
    // signature: return the length of longest single path in the tree rooted at 'root'
    public int height(TreeNode root) {
        // base case
        if (root == null) return -1;
        
        int left = height(root.left);
        int right = height(root.right);
        
        answer = Math.max(answer, left + right + 2);
        return Math.max(left + 1, right + 1);
    }   
}
```
* [灵茶山艾府](https://leetcode.cn/problems/diameter-of-binary-tree/solutions/2227017/shi-pin-che-di-zhang-wo-zhi-jing-dpcong-taqma/)
```java
private int ans;

public int diameterOfBinaryTree(TreeNode root) {
    dfs(root);
    return ans;
}

private int dfs(TreeNode node) {
    if (node == null) {
        return -1; // 下面 +1 后，对于叶子节点就刚好是 0
    }
    int lLen = dfs(node.left) + 1; // 左子树最大链长+1
    int rLen = dfs(node.right) + 1; // 右子树最大链长+1
    ans = Math.max(ans, lLen + rLen); // 两条链拼成路径
    return Math.max(lLen, rLen); // 当前子树最大链长
}
```

#### [官神影片講解](https://www.youtube.com/live/UfPMw8zD8EY?si=LW2CMWgVA0QVr4Fd) ([文字解釋](https://github.com/wisdompeak/LeetCode/tree/master/Tree/543.Diameter-of-Binary-Tree))
我們可以把任一個節點作為出發點可以到達的兩邊最長距離，但是這樣解法時間複雜度是 `O(n^2)` 級別的，我們不應該遍歷所有節點為根的樹，我們應該遍歷每個路徑的「拐點」，一條經過「拐點」的路徑是一邊上升、另一邊下降的路徑。

```js
    拐點
  /     \
 /       \
/
```

例如：以根節點 2 為拐點的最長路徑要怎麼找？就是以 2 往左和右走到葉子的距離。
```js
        1
      /   \
     2     3
   /  \ 
  5*   4*
      /
     6*
    /
   7*
```

如何計算從一個節點要走到葉子的距離，很顯然這可以用遞迴來解決。
`1` 到葉子的最長距離 = `2` 到葉子的最長距離 + 1
`2` 到葉子的最長距離 = ... 到葉子的最長距離 + 1 以此類推。
```js
        1   depth(1)
      /     = 1 +
     2            depth(2)
   /   \          = 1 +   
 ...   ...               depth(...)
```
這樣我們就由下往上遞迴計算出了每個節點到葉子的最長距離。我們在遞迴過程中，我們會計算出每個節點的左右子樹的最長距離，在這過程中我們可以同時計算出以每個節點為拐點的最長路徑，就是它的左右子樹的最長距離之和。

常見題目模式：題目問的是最長路徑，但是遞迴計算的是某個節點到葉子的最長距離，遞迴過程中同時計算出了題目所問的最長路徑。

## ~~Preorder (Double Recursion)~~
> This is not optimal solution.

For each node, we calculate the height of the left and right subtree, and the diameter of the tree is the maximum of the sum of the left and right subtree height. We can use a helper function to calculate the height of the tree and the diameter of the tree. The idea is similar to [110. Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/).

```kotlin
private var result = 0
fun diameterOfBinaryTree(root: TreeNode?): Int {
    dfs(root)
    return result
}

private fun dfs(root: TreeNode?) {
    if (root == null) return 0
    val left = getHeight(root.left)
    val right = getHeight(root.right)
    val diameter = left + right

    result = maxOf(result, diameter)

    dfs(root.left)
    dfs(root.right)
}

private fun getHeight(node: TreeNode?): Int {
    return if (node == null) 0
    else 1 + maxOf(getHeight(node.left), getHeight(node.right))
}
```
* **Time Complexity**: `O(n^2)`, where `n` is the number of nodes in the binary tree.
* **Space Complexity**: `O(H)`.