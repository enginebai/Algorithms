## [543. Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/)

The diameter of root is how many nodes will be traversaled from root (not count itself), so we calculate for every nodes and update the max result simultaneously.

```js
[1,2,3,4,5]

// The 
root=4, left=0, right=0, current=1, max=0
root=5, left=0, right=0, current=1, max=0
root=2, left=1, right=1, current=2, max=2
root=3, left=0, right=0, current=1, max=2
root=1, left=2, right=1, current=3, max=3
```

```kotlin
private var maxDiameter = 0

fun diameterOfBinaryTree(root: TreeNode?): Int {
    calculatePassedNodeCount(root)
    return maxDiameter
}

private fun calculatePassedNodeCount(root: TreeNode?): Int {
    if (root == null) return 0
    val left = calculatePassedNodeCount(root.left)
    val right = calculatePassedNodeCount(root.right)

    // Update the result of diameter of using specific node as root
    maxDiameter = max(maxDiameter, left + right)

    val count = max(left, right) + 1
    println("root=${root.`val`}, left=$left, right=$right, current=$count, max=$maxDiameter")
    
    return count
}
```

* **Time Complexity**: `O(n)` for iterating all nodes.
* **Space Complexity**: `O(h)` for recursion.

Easy understand, but bad at running time (involving lots of duplicate calculation):

```kotlin
private var maxDiameter = 0

fun diameterOfBinaryTree(root: TreeNode?): Int {
    if (root == null) return 0
    val leftDiameter = diameterOfBinaryTree(root.left)
    val rightDiameter = diameterOfBinaryTree(root.right)
    
    val leftDepth = maxDepth(root.left)
    val rightDepth = maxDepth(root.right)
    val rootDiameter = leftDepth + rightDepth
    
    maxDiameter = max(leftDiameter, rightDiameter)
    maxDiameter = max(maxDiameter, rootDiameter)
    return maxDiameter
}

private fun maxDepth(root: TreeNode?): Int {
    if (root == null) return 0
    val leftDepth = maxDepth(root.left) + 1
    var rightDepth = maxDepth(root.right) + 1
    
    return max(leftDepth, rightDepth)
}
```