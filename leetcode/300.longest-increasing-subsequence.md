## [300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/)

```js
[1, 2, 7, 8, 3, 4, 5]

LIS = 5, [1, 2, 3, 4, 5]

IS = [1, 2, 3, 4, 5] / [1, 2, 7, 8]
```

We use `dp[i]` to represent the LIS of `i`

`dp[i]` will search for the previous maximum of `dp[j]` (0 <= `j` < i) such that `A[i]` > `A[j]`. For above `3` (index=4, dp[4]), we will find the max of dp of `1` and `2`, not `7` and `8` (it's not increasing any more)

```kotlin
fun lengthOfLIS(nums: IntArray): Int {
    // We initialize all item to 1, it's the base case.
    // For every number, it's one LIS (itself)
    val dp = IntArray(nums.size) { _ -> 1 }

    for (i in 0 until nums.size) {
        // We look back to find the item which value is less than current value
        for (j in i downTo 0) {
            if (nums[i] > nums[j]) {
                dp[i] = max(dp[i], dp[j] + 1)
            }
        }
    }
    
    // We might have multiple increasing subsequence, we will 
    // find the max among them.
    var result = Int.MIN_VALUE
    for (i in 0 until dp.size) {
        result = if (dp[i] > result) dp[i] else result
    }
    return result
}
```