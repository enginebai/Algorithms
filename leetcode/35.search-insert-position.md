## [35. Search Insert Position](https://leetcode.com/problems/search-insert-position/)

To find the target value or the index to insert, then it indicates that we're going to search **the smallest number which is equals to or greater than `target`**.

```js
[1, 3, 5, 6], target = 5
       ^ // target position

[1, 3, 5, 6], target = 2
    ^ // Insert position, 3 is the smallest number which is equals to or greater than 2.
```

How can we find the smallest number which is equals to or greater than `target`? Suppose we have the following array, `X` indicate the numbers < `target`, and `O` indicate the numbers >= `target`, then the first `O` is what we want:
```js
[X, X, X, O, O, O, O]
          ^ // target
 L                 R
```

Remember that the `left` and `right` is the valid search range (inclusive), there are the following cases:
1. `middle == target`: we find the target, return the index.
2. `middle < target`: we should search the right part.
```js
[X, X, X, O, O, O, O]
    M
    | -> 
       L           R
```
3. `target < middle`: we should search the left part.

The most hard part is case 3. `target < middle`, because we are not sure if the `middle` is the smallest number >= `target`, so we keep searching the left part:
```js
[X, X, X, O, O, O, O]
                M
             <- |
 L           R       // Next round search range should be.
```

After several searching round, suppose we reach (but we don't know) the smallest number >= `target`, what range should we search for next round? Again, we are not sure if the `middle` is the smallest number >= `target`, so we search the left part:
```js
[X, X, X, O, O, O, O]
          M 
       <- | ->
       R  L
```
And this time, it breaks the while loop, and `left` pointer is the index of the smallest number >= `target`, so we return `left`.

> This approach is also applicable to the array with duplicates.

```kotlin
fun searchInsert(nums: IntArray, target: Int): Int {
    var left = 0
    var right = nums.size - 1
    
    if (target < nums[left]) return 0
    else if (target > nums[right]) return nums.size

    while (left <= right) {
        val middle = left + (right - left) / 2
        if (nums[middle] == target) return middle
        if (nums[middle] < target) {
            left = middle + 1
        } else {
            right = middle - 1
        }
    }
    return left
}
```

### Example
> Try the example with only 2 element.
```js
 Position: 0, 1
 Array:   [7, 9]
 3 => [*3, 7, 9]  0
 7 => [*7, 7, 9]  0
 8 => [7, *8, 9]  1
 9 => [7, *9, 9]  1
10 => [7, 9, *10] 2
```