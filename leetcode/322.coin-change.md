## [322. Coin Change](https://leetcode.com/problems/coin-change/)

### Backtracking
```js
Amount = 2
Coins = [2, 1, 5]

// Backtracking
      2
  /   |   \
 0    1   -3
   /  |  \
  -1  0  -4
```

We call `change` to keep changing (reducing `amount`) until it reaches 0 (we can change the coin) or negative number (we can't change successfully), and count the change time from base case. (It was TLE answer).

> **Note**: We will use `Int.MAX_VALUE / 2` to represent the positive infinite for the case we can't change. `Int.MAX_VALUE + 1` will overflow, and it will become the minimum value which will affect the result when callling `min()` function.

```kotlin
private val infinite = Int.MAX_VALUE / 2

fun coinChange(coins: IntArray, amount: Int): Int {
    if (amount == 0) return 0
    val result = dfs(coins, amount)
    return if (result == infinite) -1 else result
}

// We use infinite as invalid value, not -1, in case of wrong result from min() comparsion.
private fun dfs(coins: IntArray, amount: Int): Int {
    if (amount == 0) {
        return 0
    } else if (amount < 0) {
        // We can't change in this way
        return infinite
    } else {
        var minCoins = infinite
        for (coin in coins) {
            minCoins = min(minCoins, dfs(coins, amount - coin) + 1)
        }
        return minCoins
    }
}
```

* **Time Complexity**: It takes `O(n ^ amount)` where `n` is the numbers of coins.
* **Space Complexity**: `O(1)`.

#### Top-Down DP
With memorization (accepted) of backtracking approach, we can reduce time complexity from `O(M ^ N)` to `O(M * N)` where `M` the amount, and `N` is the size of coins. 

```kotlin
private val infinite = Int.MAX_VALUE / 2

fun coinChange(coins: IntArray, amount: Int): Int {
    // Used -1 as empty value.
    val memo = IntArray(amount + 1) { _ -> -1 }
    val result = dfs(coins, amount, memo)
    return if (result == infinite) -1 else result
}

private fun dfs(coins: IntArray, amount: Int, memo: IntArray): Int {
    if (amount == 0) {
        return 0
    } else if (amount < 0) {
        return infinite
    } else {
        if (memo[amount] != -1) return memo[amount]
        var minCoins = infinite
        for (coin in coins) {
            minCoins = min(minCoins, dfs(coins, amount - coin, memo) + 1)
        }
        memo[amount] = minCoins
        return minCoins
    }
}
```

* **Time Complexity**: `O(amount * n)`.
* **Space Complexity**: `O(amount)`

#### Bottom-Up DP
```kotlin
private val infinite = Int.MAX_VALUE / 2

fun coinChange(coins: IntArray, amount: Int): Int {
    val dp = IntArray(amount + 1) { _ -> infinite }
    dp[0] = 0
    for (i in 1..amount) {
        for (coin in coins) {
            if (i >= coin) {
                dp[i] = min(dp[i], dp[i - coin] + 1)
            }
        }
    }
    return if (dp[amount] == infinite) -1 else dp[amount]
}
```

* **Time Complexity**: `O(amount * n)`.
* **Space Complexity**: `O(amount)`

----
### Knapsack

#### Top-Down Recursion
```kotlin
private val infinite = Int.MAX_VALUE / 2

fun coinChange(coins: IntArray, amount: Int): Int {
    val result = knapsack(coins, amount, coins.size)
    return if (result != infinite) result else -1
}

private fun knapsack(coins: IntArray, amount: Int, i: Int): Int {
    if (i == 0) {
        if (amount == 0) return 0
        else return infinite
    }
    
    val skipIt = knapsack(coins, amount, i - 1)
    if (coins[i - 1] > amount) {
        return skip
    } else {
        val takeIt = knapsack(coins, amount - coins[i - 1], i)
        return min(
            takeIt + 1, 
            skipIt
        )
    }
}
```

* **Time Complexity**: `O(n ^ amount)`
* **Space Complexity**: `O(amount)` for function calls stack.

#### Top-Down DP
```kotlin
private val infinite = Int.MAX_VALUE / 2

fun coinChange(coins: IntArray, amount: Int): Int {
    val dp = Array(coins.size + 1) { _ -> IntArray(amount + 1) { _ -> -1 }}
    val result = knapsack(coins, amount, coins.size, dp)
    return if (result != infinite) result else -1
}

private fun knapsack(coins: IntArray, amount: Int, i: Int, dp: Array<IntArray>): Int {
    if (i == 0) {
        if (amount == 0) return 0
        else return infinite
    }
    
    if (dp[i][amount] != -1) return dp[i][amount]

    dp[i][amount] = knapsack(coins, amount, i - 1, dp)
    if (coins[i - 1] <= amount) {
        val takeIt = knapsack(coins, amount - coins[i - 1], i, dp)
        dp[i][amount] = min(
            dp[i][amount],
            takeIt + 1
        )
    }
    return dp[i][amount]
}
```

* **Time Complexity**: `O(amount * n)`.
* **Space Complexity**: `O(amount * n)` for DP table (2D).

#### Bottom-Up DP
```kotlin
private val infinite = Int.MAX_VALUE / 2

fun coinChange(coins: IntArray, amount: Int): Int {
    val result = knapsack(coins, amount)
    return if (result != infinite) result else -1
}

private fun knapsack(coins: IntArray, amount: Int): Int {
    val dp = Array(coins.size + 1) { _ -> IntArray(amount + 1) }
    for (i in 0..coins.size) {
        for (a in 0..amount) {
            dp[i][a] = if (a == 0) {
                0
            } else if (i == 0) {
                infinite
            } else if (coins[i - 1] > a) {
                dp[i - 1][a]
            } else {
                min(
                    dp[i - 1][a],
                    dp[i][a - coins[i - 1]] + 1
                )
            }
        }
    }
    return dp[coins.size][amount]
}
```

The fewest number of coins change from `amount=11` is the minimum of 
* `amount=10` + 1,  (Change `1`)
* `amount=9` + 1,   (Change `2`)
* `amount=6` + 1.   (Change `5`)

So the `dp[i]` = `min(dp[i - coins[i]] + 1)` for all coins.

```kotlin
private val infinite = Int.MAX_VALUE / 2

fun coinChange(coins: IntArray, amount: Int): Int {
    val result = knapsack(coins, amount)
    return if (result != infinite) result else -1
}

private fun knapsack(coins: IntArray, amount: Int): Int {
    val dp = IntArray(amount + 1) { _ -> infinite }
    dp[0] = 0
    for (i in 1..coins.size) {
        // Not from amount downTo coins[i - 1], this is unbounded knapsack
        for (a in coins[i - 1]..amount) {
            dp[a] = min(
                dp[a],
                dp[a - coins[i - 1]] + 1
            )
        }
    }
    return dp[amount]
}
```

* **Time Complexity**: `O(M * N)`.
* **Space Complexity**: `O(M)` for DP table (1D).

### Edge Cases
```js
[2], 3
[3], 2
```