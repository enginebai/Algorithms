## [110. Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/)

### Simplified Recursion
```kotlin
fun isBalanced(root: TreeNode?): Boolean {
    if (root == null) return true
    val leftHeight = height(root?.left)
    var rightHeight = height(root?.right)
    val diff = leftHeight - rightHeight
    return diff * diff <= 1 && isBalanced(root?.left) && isBalanced(root?.right)
}

private fun height(node: TreeNode?): Int {
    return if (node == null) 0
    else {
        1 + max(height(node?.left), height(node?.right))
    }
}

private fun max(n1: Int, n2: Int) = if (n1 > n2) n1 else n2
```

### My Solution (Accepted)
```kotlin
fun isBalanced(root: TreeNode?): Boolean {
    return checkBalanced(root?.left, root?.right)
}

private fun checkBalanced(n1: TreeNode?, n2: TreeNode?): Boolean {
    if (n1 == null && n2 == null) return true
    val diff = (height(n1) - height(n2))
    return (diff * diff <= 1) && checkBalanced(n1?.left, n1?.right) && checkBalanced(n2?.left, n2?.right)
}

private fun height(node: TreeNode?): Int {
    return if (node == null) 0
    else {
        1 + max(height(node?.left), height(node?.right))
    }
}

private fun max(n1: Int, n2: Int) = if (n1 > n2) n1 else n2
```