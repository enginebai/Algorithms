## [153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)

For array `[0, 1, 2, 3]`, all the combinations will be:

```js
//           Sorted  Mininum
L  M     R    L / R     
0, 1, 2, 3    O / O     L // Not rotated
3, 0, 1, 2    X / O     L
2, 3, 0, 1    O / X     R
1, 2, 3, 0    O / X     R
```

```js
//     Sorted  Minimum
L       L / R
M  R
2, 3    O   O     L
3, 2    O   X     R
```

* As you can see above, when the middle value > right value (right part is not sorted), then the minimum must be in the right part, otherwise, it will be left part. 
* In general, if the array is not rotated, the minimum is the leftmost element, otherwise, the minimum will be located at the the part which is not sorted (pivot part).
* And we store the minimum from middle value for each round.

> Maybe using the diagram to help you understand the logic: https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/14436/revised-binary-search/comments/191339

```kotlin
fun findMin(nums: IntArray): Int {
    var min = Int.MAX_VALUE
    var start = 0
    var end = nums.size - 1
    while (start <= end) {
        val middle = start + (end - start) / 2
        min = if (nums[middle] < min) nums[middle] else min

        if (nums[end] < nums[middle]) start = middle + 1
        else end = middle - 1
    }
    return min
}
```

