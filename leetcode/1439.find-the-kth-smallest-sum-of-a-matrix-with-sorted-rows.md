# [1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows](https://leetcode.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/)

## Hints
- How can you efficiently generate the next smallest sum from a matrix where each row is sorted?
- What data structure helps you always get the next smallest sum?
- Can you avoid generating all possible combinations explicitly?

## Breakdowns
> 1. What is the brute force approach?

Generate all possible combinations by picking one element from each row, compute their sums, and sort to find the k-th smallest. This is not feasible for large matrices due to exponential growth.

> 2. How can we do better using a heap?

Since each row is sorted, the smallest sum is obtained by picking the first element from each row. The next smallest sum can be generated by incrementing the index in one of the rows. Use a min-heap to always expand the next possible smallest sum, and a set to avoid duplicate index combinations.

## Key Insights
- This problem is a generalization of the k-way merge pattern, similar to [@373.find-k-pairs-with-smallest-sums.md](373.find-k-pairs-with-smallest-sums.md), but for more than two arrays (rows).
- The state can be represented by a tuple of indices, one for each row, and the sum of the selected elements.
- Always push the next possible combinations by incrementing the index in one row at a time, and use a set to avoid revisiting the same combination.
- The heap ensures we always process the next smallest sum.

## Min-Heap (Priority Queue)
The most popular and efficient approach is to use a min-heap to always expand the next smallest sum combination. Start with the tuple of all zeros (first element in each row), and for each pop, increment the index in each row (if possible) to generate new combinations.

```kotlin
import java.util.PriorityQueue

fun kthSmallest(mat: Array<IntArray>, k: Int): Int {
    val m = mat.size
    val n = mat[0].size
    val minHeap = PriorityQueue<IntArray> { i1, i2 ->
        var sum1 = 0
        var sum2 = 0
        for (r in 0 until m) {
            sum1 += mat[r][i1[r]]
            sum2 += mat[r][i2[r]]
        }
        sum1 - sum2
    }
    val indices = IntArray(m)
    val added = HashSet<String>()
    minHeap.add(indices)
    added.add(indices.joinToString(","))
    var i = 0
    var ans = 0
    while (i < k && minHeap.isNotEmpty()) {
        val current = minHeap.poll()
        ans = 0
        for (r in 0 until m) {
            ans += mat[r][current[r]]
        }
        for (j in 0 until current.size) {
            val next = current.clone()
            if (next[j] + 1 < n) {
                next[j]++
                val hash = next.joinToString(",")
                if (hash in added) continue
                minHeap.add(next)
                added.add(hash)
            }
        }
        i++
    }
    return ans
}
```
- **Time Complexity**: `O(k * m * log k)` (each heap operation is `log k`, and for each pop we may push up to `m` new combinations)
- **Space Complexity**: `O(k * m)` (heap and set)

## Edge Cases
- If `k` is larger than the total number of possible combinations, return the largest possible sum.
- If the matrix has only one row, the problem reduces to finding the k-th smallest element in a sorted array.
- If all rows have only one element, the answer is the sum of those elements.
- Duplicate values in rows: ensure combinations are tracked by indices, not values.

## Pitfalls
- Not using a set to avoid duplicate index combinations (can lead to TLE).
- Forgetting to check bounds when incrementing indices.
- Not handling the case where `k` exceeds the number of possible combinations.

## Similar or Follow-up Problems
- [373. Find K Pairs with Smallest Sums](373.find-k-pairs-with-smallest-sums.md)
- [378. Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/)

---

# My Original Notes

## K-way Merge
We can merge the rows one by one using the same approach as [373. Find K Pairs with Smallest Sums](../leetcode/373.find-k-pairs-with-smallest-sums.md), and the result is a sorted list.

```kotlin
fun kthSmallest(mat: Array<IntArray>, k: Int): Int {
    var result = mat.first().toList()
    for (i in 1 until mat.size) {
        result = mergeTwoRows(result, mat[i], k)
    }
    return result[k - 1]
}

// By K-way Merge
private fun mergeTwoRows(nums1: List<Int>, nums2: IntArray, k: Int): List<Int> {
    val minHeap = PriorityQueue<Pair<Int, Int>>() { p1, p2 ->
        (nums1[p1.first] + nums2[p1.second]) - (nums1[p2.first] + nums2[p2.second])
    }
    val results = mutableListOf<Int>()
    for (i in nums1.indices) {
        minHeap.add(i to 0)
    }
    val added = HashSet<Pair<Int, Int>>()
    val totalSize = (nums1.size * nums2.size).coerceAtMost(k)
    while (minHeap.isNotEmpty() && results.size < totalSize) {
        val (i, j) = minHeap.poll()
        results.add(nums1[i] + nums2[j])

        if (j + 1 < nums2.size) {
            minHeap.add(i to j + 1)
        }
    }
    return results
}

// Or equivalent, by heap:
private fun mergeTwoRows(nums1: List<Int>, nums2: IntArray, k: Int): List<Int> {
    val minHeap = PriorityQueue<Pair<Int, Int>>() { p1, p2 ->
        (nums1[p1.first] + nums2[p1.second]) - (nums1[p2.first] + nums2[p2.second])
    }
    val results = mutableListOf<Int>()
    val added = HashSet<Pair<Int, Int>>()
    minHeap.add(0 to 0)
    val totalSize = (nums1.size * nums2.size).coerceAtMost(k)
    while (minHeap.isNotEmpty() && results.size < totalSize) {
        val (i, j) = minHeap.poll()
        results.add(nums1[i] + nums2[j])

        if (i + 1 < nums1.size && added.contains(i + 1 to j).not()) {
            minHeap.add(i + 1 to j)
            added.add(i + 1 to j)
        }
        if (j + 1 < nums2.size && added.contains(i to j + 1).not()) {
            minHeap.add(i to j + 1)
            added.add(i to j + 1)
        }
    }
    return results
}
```

## Heap
We use the similar idea from [373. Find K Pairs with Smallest Sums](../leetcode/373.find-k-pairs-with-smallest-sums.md), we maintain a multi-pointer to track the current index of each row, that is `indices[r]` is the current column index of at `r`th row:

```js
indices = [a, b, c]
_, a, _, _
_, _, b, _
c, _, _, _
```

where `mat[0][a] + mat[1][b] + mat[2][c]` is the sum of the current combination. Since all rows are sorted, so moving the pointer to right will increase the sum.

We use a min heap to store the current combination, and process `k` times to get the `k`th smallest sum.

```js
// Current combination
x, _, _
y, _, _
z, _, _

// Next combination
_, x, _    x, _, _   x, _, _
y, _, _    _, y, _   y, _, _
z, _, _    z, _, _   _, z, _
```

If we pick one combination, we need to add the next column of the row to the heap, and we need to avoid duplicate combinations.

```kotlin
fun kthSmallest(mat: Array<IntArray>, k: Int): Int {
    val m = mat.size
    val n = mat[0].size
    val minHeap = PriorityQueue<IntArray>() { i1, i2 ->
        var sum1 = 0
        var sum2 = 0
        for (r in 0 until m) {
            sum1 += mat[r][i1[r]]
        }
        for (r in 0 until m) {
            sum2 += mat[r][i2[r]]
        }
        sum1 - sum2
    }

    val indices = IntArray(m)
    val added = HashSet<String>()
    minHeap.add(indices)
    added.add(indices.hash())
    var i = 0
    var ans = 0
    while (i < k && minHeap.isNotEmpty()) {
        val current = minHeap.poll()
        ans = 0
        for (r in 0 until m) {
            ans += mat[r][current[r]]
        }

        for (j in 0 until current.size) {
            val next = current.clone()
            if (next[j] + 1 < n) {
                next[j]++
                val hash = next.hash()
                if (hash in added) {
                    continue
                }
                minHeap.add(next)
                added.add(hash)
            }
        }
        i++
    }
    return ans
}

private fun IntArray.hash(): String {
    val str = StringBuilder()
    for (num in this) {
        str.append("${num},")
    }
    return str.toString()
}
```

## Binary Search
> TODO: