# [139. Word Break](https://leetcode.com/problems/word-break/)

## Observation
```js
// For word "cars" and dictionary ["car", "ca", "rs"]
f(car) =
    f(ca) + "r" in dict ||
    f(ca) =
        f(c) + "a" in dict ||
        f() + "ca" in dict
    f(c) + "ar" in dict ||
    f(c) = 
        f() + "c" in dict
    f() + "car" in dict
```

1. **Optimal substructure**: We can break down the string into smaller substrings, and we can build the substrings from dictionary to build the solution for entire string.
2. **Overlapping subproblems**: When breaking down the string, we might have same substrings (`f(c)` from above example), and we can reuse the solution.
3. **Memoization**: We keep track of whether substrings can be built from dictionary.

Suppose we break down the string into `s[0:i]` and `s[i:]`, if we can build `s[0:i]` from dictionary recursively and `s[i:]` exists in dictionary, then we can build `s[0:i] + s[i:]` from dictionary. Then we break down `s[0:i]` into `s[0:j]` and `s[j:i]`, and if we can build `s[0:j]` from dictionary recursively and `s[j:i]` exists in dictionary, then we can build `s[0:j] + s[j:i]` from dictionary. And so on. Therefore, we can solve this problem by dynamic programming.

```js
// f(s) = word break function of input string s.
f(s) = f(s[0:i]) && if s[i:] in dict for i in 1 to s.length

// Break into smaller substrings
f(s[0:i]) = f(s[0:j]) && if s[j:i] in dict for j in 1 to i

f(s[0:j]) = f(s[0:k]) && if s[k:j] in dict for k in 1 to j

// ... so on.
```

Here we don't know the `i` and `j` for breaking down the string, so we will try all possible `i` and `j` (iterate all substrings) to find if we can build the string from dictionary.

For example
```kotlin
f('leetcode') =
    (f('leetcod') && 'e' in dict) ||
    (f('leetco') && 'de' in dict) ||
    (f('leetc') && 'ode' in dict) ||
    (f('leet') && 'code' in dict) ||
    (f('lee') && 'tcode' in dict) ||
    (f('le') && 'etcode' in dict) ||
    (f('l') && 'eetcode' in dict) ||
    (f('') && 'leetcode' in dict)
```

## Top-Down DP
```kotlin
fun wordBreak(s: String, wordDict: List<String>): Boolean {
    val memo = hashMapOf<String, Boolean>()
    return breakdown(s, HashSet(wordDict), memo)
}

private fun breakdown(s: String, dict: HashSet<String>, memo: HashMap<String, Boolean>): Boolean {
    if (s.isEmpty() || dict.contains(s)) return true
    if (memo.containsKey(s)) return memo[s]!!
    for (end in 1..s.length) {
        // NOTE: We don't write as `breakdown(s.substring(0, end), dict, memo) && dict.contains(s.substring(end)))` that leads to StackOverflowError because we evaluate the second condition even the first condition is false, which causes unnecessary recursive calls.
        // We chech if s[end:] in dict first before making recursive call, this ensures we only make recursive call when s[end:] in dict.
        if (dict.contains(s.substring(end)) && breakdown(s.substring(0, end), dict, memo)) {
            memo[s] = true
            return true
        }
    }
    memo[s] = false
    return false
}
```

* **Time Complexity**: `O(n^2)` where `n` is the length of string.
* **Space Complexity**: `O(n)` for memoization.

## Bottom-Up DP
Let's define `dp[i]` as the state if we can build the substring `s[0:i]` from dictionary, and the state transition will be:

```js
// s = 0.....j.....i
// The state of s[0:i] = s[0:j] + s[j:i]
dp[i] = 
    dp[j]       // The state of s[0:j], 
    && s[j:i]   // The remaining substring, check if it in the dictionary
```

For example, `"cars"` and `["car", "ca", "rs"]`:

We will iterate `i` from 0 to `len` for find if we can build substring `s[0:i]`:

```js
j  i  c a r s
0, 1, c        // dp[0] && dict.contains("c") = false

0, 2, c a      // dp[0] && dict.contains("ca") = true
1, 2,   a

0, 3, c a r
1, 3,   a r
2, 3,     r

0, 4, c a r s
1, 4,   a r s
2, 4,     r s
3, 4,       s
```

```kotlin
fun wordBreak(s: String, wordDict: List<String>): Boolean {
    val wordDictSet = HashSet<String>(wordDict)
    // We define dp size as s.length + 1 bacause the base case is empty string, that is s[0:0] = "".
    val dp = BooleanArray(s.length + 1)
    // Base case is empty string, which is true.
    dp[0] = true
    for (end in 1..s.length) {
        for (start in 0..end) {
            val suffix = s.substring(start, end)
            if (dp[start] && wordDictSet.contains(suffix)) {
                dp[end] = true
                break
            }
        }
    }
    return dp[s.length]
}
```

## Dry Run
```js
println(wordBreak("cars", listOf("car", "rs", "ca")))
0, 1, c
true,false,false,false,false,
0, 2, ca
true,false,true,false,false,
0, 3, car
true,false,true,true,false,
0, 4, cars
1, 4, ars
2, 4, rs
true,false,true,true,true,
true

println(wordBreak("cars", listOf("c", "s", "ar")))
0, 1, c
true,true,false,false,false,
0, 2, ca
1, 2, a
true,true,false,false,false,
0, 3, car
1, 3, ar
true,true,false,true,false,
0, 4, cars
1, 4, ars
2, 4, rs
3, 4, s
true,true,false,true,true,
true

println(wordBreak("cars", listOf("s", "ar")))
0, 1, c
true,false,false,false,false,
0, 2, ca
1, 2, a
true,false,false,false,false,
0, 3, car
1, 3, ar
2, 3, r
true,false,false,false,false,
0, 4, cars
1, 4, ars
2, 4, rs
3, 4, s
true,false,false,false,false,
false
```

* **Time Complexity**: `O(n^2)` where `n` is the length of string.
* **Space Complexity**: `O(n)` for dp table.

Here we don't iterate to build substring start from `i`, because the `dp[i]` represent the state of `s[0:i]`.

```js
c a r s
-------
c
c a
c a r
c a r s
  a
  a r
  a r s
    r
    r s
      s
```