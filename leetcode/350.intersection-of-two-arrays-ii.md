## [350. Intersection of Two Arrays II](https://leetcode.com/problems/intersection-of-two-arrays-ii/)
### Hash Table
```kotlin
fun intersect(nums1: IntArray, nums2: IntArray): IntArray {
    // We will build hash table on the array with shorter length
    if (nums1.size > nums2.size) return intersect(nums2, nums1)
    
    val hashTable = hashMapOf<Int, Int>()
    for (i in 0 until nums1.size) {
        hashTable[nums1[i]] = (hashTable[nums1[i]] ?: 0) + 1
    }
    val results = mutableListOf<Int>()
    for (j in 0 until nums2.size) {
        if (hashTable.containsKey(nums2[j])) {
            results.add(nums2[j])

            val count = hashTable[nums2[j]]!!
            if (count - 1 > 0) {
                hashTable[nums2[j]] = count - 1
            } else {
                hashTable.remove(nums2[j])
            }
        }
    }
    return results.toIntArray()
}
```

* **Time Complexity**: `O(m + n)`.
* **Space Complexity**: `O(min(m, n))` for hash table.

### Two Pointers
```kotlin
fun intersect(nums1: IntArray, nums2: IntArray): IntArray {
    nums1.sort()
    nums2.sort()

    val results = mutableListOf<Int>()
    var index1 = 0
    var index2 = 0
    while (index1 < nums1.size && index2 < nums2.size) {
        if (nums1[index1] < nums2[index2]) index1++
        else if (nums1[index1] > nums2[index2]) index2++
        else {
            // Common part
            // [2, 2] / [2, 2, 2, 2] or reverse
            results.add(nums1[index1])
            index1++
            index2++
        }
    }

    return results.toIntArray()
}
```

* **Time Complexity**: `O(m lg m + n lg n)`.
* **Space Complexity**: `O(min(m, n))` for result.