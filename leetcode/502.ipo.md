# [502. IPO](https://leetcode.com/problems/ipo/description/)

## Heap (Greedy)

- If we have enough capital, we add all projects which capital <= capital to the max heap as candidates. Since we want to maximize the profit, we use a max heap, and we want to filter out the projects which capital <= capital, so we sort the projects by capital.
- We select the project with the maximum profit from the max heap and add the profit to the capital.
- We repeat the above steps until we have selected k projects or there is no more project to select.

```kotlin
data class Project(
    val profit: Int,
    val capital: Int
)

fun findMaximizedCapital(K: Int, W: Int, profits: IntArray, capital: IntArray): Int {
    val n = profits.size
    val projects = Array(n) {
        Project(profits[it], capital[it])
    }
    val maxHeap = PriorityQueue(compareByDescending<Int> {
        projects[it].profit
    }.thenBy {
        projects[it].capital
    })
    projects.sortBy { it.capital }
    var k = K
    var w = W
    var i = 0
    // No need to check if i < n here, because we will break the loop when there is no more project to select
    while (k > 0) {
        // Add all projects which capital <= w to the max heap
        while (i < n && projects[i].capital <= w) {
            maxHeap.add(i)
            i++
        }

        // Execute the project with the maximum profit
        if (maxHeap.isNotEmpty()) {
            val index = maxHeap.poll()
            w += projects[index].profit
            k--
        } else { // No more project to select
            break
        }
    }
    return w
}
```

- Time complexity: `O(n log n + k log n)`
  - `O(n)` for project
  - `O(n log n)` for sort
  - `O(k * log n)` for executing project
- Space complexity: `O(n)`
  - `O(n)` for projects
  - `O(log n)` for sort (quicksort)
  - `O(n)` for heap
