# [297. Serialize and Deserialize Binary Tree](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/)

Key points:
* We build a preorder traversal list, and **add special notation for null child**. 
* We can serialize to preorder traversal and also can deserialize from preorder traversal.

> Nice illustration:
> * https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/solution/shou-hui-tu-jie-gei-chu-dfshe-bfsliang-chong-jie-f/

```kotlin
class Codec() {
    
    private val nullString = "n"
    private val itemSeparator = ","
    
    fun serialize(root: TreeNode?): String {
        if (root == null) return ""
        val traversals = mutableListOf<String>()
        preOrderTraversal(root, traversals)
        return traversals.joinToString(itemSeparator)
    }
    
    fun deserialize(data: String): TreeNode? {
        if (data.isEmpty()) return null
        
        val traversals = data.split(itemSeparator).toMutableList()
        return buildTree(traversals)
    }
    
    private fun preOrderTraversal(node: TreeNode?, results: MutableList<String>) {
        results.add(if (node != null) node.`val`.toString() else nullString)
        if (node == null) return
        preOrderTraversal(node?.left, results)
        preOrderTraversal(node?.right, results)
    }
    
    // Key functions
    private fun buildTree(traversals: MutableList<String>): TreeNode? {
        if (traversals.isEmpty()) return null
        val first = traversals.first()
        traversals.removeAt(0)
        if (first == nullString) {
            return null
        }
        val newNode = TreeNode(first.toInt())
        newNode.left = buildTree(traversals)
        newNode.right = buildTree(traversals)
        return newNode
    }
}
```

## BFS
```kotlin
class Codec() {

    private val nullNode = TreeNode(Int.MAX_VALUE)
    private val nullValue = "#"

    // Encodes a URL to a shortened URL.
    fun serialize(root: TreeNode?): String {
        if (root == null) return nullValue
        val queue = ArrayDeque<TreeNode>()
        queue.add(root)
        val nodes = mutableListOf<String>()
        while (queue.isNotEmpty()) {
            val node = queue.removeFirst()

            if (node == nullNode) {
                nodes.add(nullValue.toString())
            } else {
                nodes.add(node.`val`.toString())
                if (node.left != null) {
                    queue.addLast(node.left!!)
                } else {
                    queue.addLast(nullNode)
                }

                if (node.right != null) {
                    queue.addLast(node.right!!)
                } else {
                    queue.addLast(nullNode)
                }
            }
        }
        return nodes.joinToString(",")
    }

    // Decodes your encoded data to tree.
    fun deserialize(data: String): TreeNode? {
        if (data.isEmpty()) return null
        val splits = data.split(",")
        val root = TreeNode(splits.first().toInt())
        var i = 1
        val queue = ArrayDeque<TreeNode>()
        queue.addLast(root)
        while (queue.isNotEmpty() && i < splits.size) {
            val node = queue.removeFirst()
            if (i < splits.size) {
                if (splits[i] != nullValue) {
                    val left = TreeNode(splits[i].toInt())
                    node.left = left
                    queue.addLast(left)
                }
                i++
            }
            if (i < splits.size) {
                if (splits[i] != nullValue) {
                    val right = TreeNode(splits[i].toInt())
                    node.right = right
                    queue.addLast(right)
                }
                i++
            }
        }
        return root
    }
}
```