# [127. Word Ladder](https://leetcode.com/problems/word-ladder/)

> This problem is asking for the shortest path of the numbers of **nodes**, not the edges.

## Preworks

> Question: How to find the adjacent words efficiently?

There are two ways to find the adjacent words:

1. Wildcard buckets (a.k.a. pattern indexing)
2. Substitution on-the-fly

### Wildcard Buckets

Example word list: `["hot", "dot", "hit", "lot", "log"]`, we can build the patterns:

- `"hot"`: `*ot`, `h*t`, `ho*`
- `"dot"`: `*ot`, `d*t`, `do*`
- `"hit"`: `*it`, `h*t`, `hi*`
- ...

Bucket map (pattern -> word list):

- `*ot`: `["hot", "dot", "lot"]`
- `h*t`: `["hot", "hit"]`
- `ho*`: `["hot"]`
- ...

To query the adjacent words of `"hot"`, we generate the patterns: `*ot`, `h*t`, `ho*` and get the corresponding word lists: `["hot", "dot", "lot"]`.

### Substitution on-the-fly

For the word `word`, we iterate each character and replace it from `a` to `z`, and check if the new word is in the word list.

Example neighbors of `"hot"`:

- `i=0`: `aot`, `bot`, `...`, `zot` → matches in set: `dot`, `lot`
- `i=1`: `hat`, `hbt`, `...`, `hzt` → match: `hit`
- `i=2`: `hoa`, `hob`, `...`, `hoz` → (none in set)

The neighbors of `"hot"` are `["dot", "lot", "hit"]`.

## BFS

We use word as nodes and transitions as edges, and it's a undirected graph (`hit - hot`, we can transform from `hit` to `hot`, and vice versa.

```js
hit - hot - dot - dog - cog
        \     |     |  /
         -- lot - log -
```

We start from the `beginWord` and traverse the graph until we find the `endWord`. We use BFS to find the shortest path. We need the shortest transformation, BFS guarantees that we find the shortest path first.

> TODO: Understand "我们先只关注 hit 和 hot 这两个单词之间的转换，如下所示，[可以借助 `h*t` 来作媒介](https://leetcode.cn/problems/word-ladder/solutions/2817913/chao-xiang-xi-de-ceng-ceng-di-jin-san-ch-5kmy/)。"

```kotlin
/**
beginWord = "aa", endWord = "bb", wordList = ["ab", "bb", "ba"]
"aa" -> "ab" -> "bb"
  1       2       3

// Initial state
Push "aa" -> d = 1

// In while loop: pop current node, push adjacent nodes, update distance
Pop "aa" -> Push "ab" -> d = 2
Pop "ab" -> Push "bb" -> d = 3
Pop "bb" -> Found "bb", return 3
 */
fun ladderLength(beginWord: String, endWord: String, wordList: List<String>): Int {
    val wordSet = wordList.toHashSet()
    if (endWord !in wordSet) return 0
    val queue = ArrayDeque<String>()
    val visited = HashSet<String>()

    queue.addLast(beginWord)
    visited.add(beginWord)
    // +1 for beginWord
    var length = 1
    while (queue.isNotEmpty()) {
        val size = queue.size
        repeat (size) {
            val word = queue.removeFirst()
            if (word == endWord) return length
            val chars = word.toCharArray()
            for (i in 0 until chars.size) {
                val original = chars[i]
                for (c in 'a'..'z') {
                    if (c == original) continue
                    chars[i] = c
                    val newWord = String(chars)
                    if (newWord in wordSet && newWord !in visited) {
                        queue.addLast(newWord)
                        visited.add(newWord)
                    }
                }
                // Revert the character we replaced above
                chars[i] = original
            }
        }
        length++
    }
    return 0
}
```

- **Time Complexity**: `O(W * L)`
  - Word processing: For each word, we iterate through each character position (`L` positions) and try all 26 letters (`26` possibilities). This gives us `O(L * 26) = O(L)` per word.
  - BFS traversal: In the worst case, we might visit all `W` words in the word list. For each visited word, we spend `O(L)` time generating neighbors.
- **Space Complexity**: `O(W * L)`
  - Queue: In the worst case, the queue might contain all `W` words, each of length `L`. This gives us `O(W * L)`.
  - Visited set: We might mark all `W` words as visited, each of length `L`. This gives us `O(W * L)`.
  - WordSet: Converting the word list to a HashSet takes `O(W * L)` space.

## Bidirectional BFS

We also can use bidirectional BFS to find the shortest path. We start from the `beginWord` and `endWord` at the same time. We traverse the graph until we find the intersection of the two paths.

```js
begine "ab" -> "ab"
         1       3 // Find intersection
   end "bb" -> "ab"
         2
```

```kotlin
fun ladderLength(beginWord: String, endWord: String, wordList: List<String>): Int {
    val wordSet = wordList.toHashSet()
    // We need to check if endWord is in wordList first
    if (endWord !in wordSet) return 0
    val queue1 = ArrayDeque<String>()
    val visited1 = HashSet<String>()
    val queue2 = ArrayDeque<String>()
    val visited2 = HashSet<String>()

    queue1.addLast(beginWord)
    visited1.add(beginWord)
    queue2.addLast(endWord)
    visited2.add(endWord)
    var length = 1
    while (queue1.isNotEmpty() && queue2.isNotEmpty()) {
        if (queue1.size <= queue2.size) {
            if (expand(queue1, wordSet, visited1, visited2)) return length
            length++
        } else {
            if (expand(queue2, wordSet, visited2, visited1)) return length
            length++
        }
    }
    return 0
}

private fun expand(queue: ArrayDeque<String>, wordSet: HashSet<String>, visited: HashSet<String>, anotherVisited: HashSet<String>): Boolean {
    val size = queue.size
    repeat (size) {
        val word = queue.removeFirst()
        if (word in anotherVisited) return true

        // We use substitution on-the-fly to find the adjacent words.
        val chars = word.toCharArray()
        for (i in 0 until chars.size) {
            val original = chars[i]
            for (c in 'a'..'z') {
                if (c == original) continue
                chars[i] = c
                val newWord = String(chars)
                if (newWord in wordSet && newWord !in visited) {
                    queue.addLast(newWord)
                    visited.add(newWord)
                }
            }
            chars[i] = original
        }
    }
    return false
}
```

- **Time Complexity**: `O(W * L)`

  - Word processing: Same as BFS - `O(L)` per word for generating neighbors.
  - Bidirectional BFS traversal: The key insight is that bidirectional BFS typically explores fewer nodes than unidirectional BFS. Instead of exploring from one end to the other (which could be `O(W)` nodes), bidirectional BFS explores from both ends simultaneously.
  - Optimal case: If the shortest path has length `D`, then each direction explores roughly `O(D/2)` nodes instead of `O(D)` nodes.

- **Space Complexity**: `O(W * L)`
  - Two queues: Each queue might contain up to `O(W/2)` words in the optimal case, but worst case could be `O(W)` words. Each word is of length `L`, so `O(W * L)`.
  - Two visited sets: Similar to the queues, we might mark all `W` words as visited across both sets. This gives us `O(W * L)`.
  - WordSet: Same as BFS - `O(W * L)`.

### Key Advantage of Bidirectional BFS

The main advantage is in the average-case time complexity. While both algorithms have the same worst-case complexity of `O(W * L)`, bidirectional BFS typically explores significantly fewer nodes in practice, especially when the shortest path is long. This is because:

1. It explores from both ends simultaneously
2. It stops as soon as there's an intersection between the two search frontiers
3. The search space grows exponentially with distance, so exploring from both ends reduces the total search space dramatically

> - [Nice explanation](https://leetcode.cn/problems/word-ladder/solutions/276923/yan-du-you-xian-bian-li-shuang-xiang-yan-du-you-2/)
> - [Nice illustration](https://leetcode.cn/problems/word-ladder/solutions/2817913/chao-xiang-xi-de-ceng-ceng-di-jin-san-ch-5kmy/)

## Different Implementations (AC)

> Please skip this section which is more like a note for myself.

```js
beginWord = "aa";
endWord = "bb";
wordList = ["ab", "bb", "ba"];
```

- Enqueue the `beginWord` and mark it as visited immediately. (Our first implementation)

```kotlin
/**
Push "aa" -> d = 1
Pop "aa" -> Push "ab" -> d = 2
Pop "ab" -> Found "bb", return 3
 */
fun ladderLength(beginWord: String, endWord: String, wordList: List<String>): Int {
    if (beginWord == endWord) return 0
    val queue = ArrayDeque<String>()
    val visited = hashSetOf<String>()
    queue.addLast(beginWord)
    visited.add(beginWord)

    var distance = 1
    while (!queue.isEmpty()) {
        val size = queue.size
        for (i in 0 until size) {
            val currentWord = queue.removeFirst()
            for (word in wordList) {
                if (visited.contains(word)) continue
                if (getDiff(currentWord, word) > 1) continue
                // Check if endWord at adjacent words
                if (word == endWord) return distance + 1
                visited.add(word)
                queue.addLast(word)
            }
        }
        distance++
    }
    return 0
}
```

- Same implementation as above, but initialize `distance` as `0` and return `distance + 1` when found the `endWord`.

```kotlin
/**
Push "aa" -> d = 0
Pop "aa" -> Push "ab" -> d = 1
Pop "ab" -> Push "bb" -> d = 2
Pop "bb" -> Found "bb", return 3
 */
fun ladderLength(beginWord: String, endWord: String, wordList: List<String>): Int {
    val dict = HashSet<String>(wordList)
    val queue = ArrayDeque<String>()
    val visited = HashSet<String>()
    queue.addLast(beginWord)
    visited.add(beginWord)

    var distance = 0
    while (queue.isNotEmpty()) {
        val size = queue.size
        for (i in 0 until size) {
            val word = queue.removeFirst()

            if (word == endWord) return distance + 1
            for (adj in dict) {
                if (adj in visited) continue
                val diff = getDiff(word, adj)
                if (diff != 1) continue
                queue.addLast(adj)
                visited.add(adj)
            }
        }
        distance++
    }
    return 0
}
```

- Use a data class to store the word and distance.

```kotlin
data class MyNode(
    val word: String,
    val distance: Int
)

fun ladderLength(beginWord: String, endWord: String, wordList: List<String>): Int {
    val queue = ArrayDeque<MyNode>()
    val visited = HashSet<String>()
    queue.addLast(MyNode(beginWord, 1))
    visited.add(beginWord)
    while (queue.isNotEmpty()) {
        // Please note that we don't need level by level traversal!!
        val node = queue.removeFirst()
        val word = node.word
        val distance = node.distance
        if (word == endWord) return distance

        for (adj in wordList) {
            if (adj in visited) continue
            val diff = getDiff(word, adj)
            if (diff != 1) continue
            queue.addLast(MyNode(adj, distance + 1))
            visited.add(adj)
        }
    }
    return 0
}
```

- Enqueue the adjacent nodes of `beginWord`

```kotlin
/**
d = 1 -> Push "ab" ->
d = 2 -> Pop "ab" -> Push "aa" -> Push "bb" ->
d = 3 -> Pop "aa" -> Pop "bb" -> Found "bb", return 3
 */
fun ladderLength(beginWord: String, endWord: String, wordList: List<String>): Int {
    val queue = ArrayDeque<String>()
    val visited = HashSet<String>()
    for (word in wordList) {
        // We enqueue the adjacent nodes of beginWord
        if (getDiff(beginWord, word) == 1) {
            queue.addLast(word)
            visited.add(word)
        }
    }
    var distance = 1
    while (queue.isNotEmpty()) {
        // We should increase distance first, not after the loop
        distance++
        val size = queue.size
        repeat(size) {
            // Same logic as above
            val word = queue.removeFirst()
            if (word == endWord) return distance
            for (adj in wordList) {
                if (adj in visited) continue
                val diff = getDiff(word, adj)
                if (diff != 1) continue

                queue.addLast(adj)
                visited.add(adj)
            }
        }
    }
    return 0
}
```

- Enqueue the `beginWord` but mark it as visited when dequeued. (Those are similar to the above implementations)

```kotlin
fun ladderLength(beginWord: String, endWord: String, wordList: List<String>): Int {
    val queue = ArrayDeque<String>()
    queue.addLast(beginWord)
    var distance = 1
    val visited = HashSet<String>()
    while (queue.isNotEmpty()) {
        val size = queue.size
        for (i in 0 until size) {
            val word = queue.removeFirst()
            if (visited.contains(word)) continue

            if (word == endWord) return distance
            visited.add(word)
            val adjWords = getAdjWords(word, wordList)
            adjWords.forEach { adj ->
                queue.addLast(adj)
            }
        }
        distance++
    }
    return 0
}
```
