## [41. First Missing Positive](https://leetcode.com/problems/first-missing-positive/)

### Hash
For array of size = `n`, the first missing positive numbe will be in the range of `1` to `n + 1` (inclusive).

**Idea!!** So we are going to **use array itself as hash table**, we use array index as key, and mark the element of that index as seen. For example, if we mark `A[1]` as negative number when we see `2` (not missing) (and 0-based index, we have to -1 for index).

But before mark the number to negative, we might contain zero or negative in the beginning, and they are not the answer, so we will change the them number to `n + 1` (or some number out of normal range `[1..n + 1]`)

Then we start to mark the number we've seen and iterate the whole array to check if any number was not marked as negative. If all numbers were marked, then return `n + 1`. (`[1, 2, 3]` the answer will be 4)

```kotlin
fun firstMissingPositive(nums: IntArray): Int {
    val n = nums.size
    for (i in 0 until n) {
        if (nums[i] <= 0) nums[i] = n + 1
    }
    for (i in 0 until n) {
        // The number might be marked negative before, we have to operate using absolute numbers.
        val value = abs(nums[i])
        if (value in 1..n) {
            // -1 for 0-based index.
            // Using abs() for the same reason above
            nums[value - 1] = -abs(nums[value - 1])
        }
    }
    for (i in 0 until n) {
        if (nums[i] > 0) return i + 1
    }
    
    return n + 1
}
```
* **Time Complexity**: `O(n)`.
* **Space Complexity**: `O(1)`, we use array itself as hash table.

### Cyclic Sort
We can modify the previous solution, we still use array itself as hash table, and index as key, but this approach is to position the item to the index it should be by swapping. That is `nums[i] = value` should place at index `value - 1` (0-based index).

```js
index = 0, 1, 2, 3
value = 1, 2 ,3 ,4 // It should be
```

For example, `2` should be placed at `A[1]` (-1 for 0-based index), `[3, 4, -1, 1]` shoule be placed like `[1, -1, 3, 4]`

```kotlin
fun firstMissingPositive(nums: IntArray): Int {
    val n = nums.size
    var i = 0
    while (i < n) {
        // 5 -> place A[4]
        val value = nums[i]
        if (value in 1..n && nums[value - 1] != value) {
            nums.swap(i, value - 1)
        } else {
            i++
        }
    }

    // Or equivalent:
    for (i in 0 until n) {
        // We keep swapping until the value is in the correct position or out of boundary.
        // Here we can't store the value = nums[i], because we might update the value in the while loop.
        while (nums[i] in 1..n && nums[nums[i] - 1] != nums[i]) {
            nums.swap(i, nums[i] - 1)
        }
    } 

    for (i in 0 until n) {
        if (nums[i] != i + 1) return i + 1
    }
    return n + 1
}

private fun IntArray.swap(i: Int, j: Int) {
    val temp = this[i]
    this[i] = this[j]
    this[j] = temp
}
```

* **Time Complexity**: `O(n)`.
* **Space Complexity**: `O(1)`, we use array itself as hash table.