## [334. Increasing Triplet Subsequence](https://leetcode.com/problems/increasing-triplet-subsequence)

We iterate from left-hand side and right-hand side to find the minimum and maximum of `i` index. Then iterate again to see if `nums[i]` is between the previous minimum `min[i - 1]` and next maximum `max[i + 1]`.

```kotlin
fun increasingTriplet(nums: IntArray): Boolean {
    if (nums.size < 3) return false
    val n = nums.size
    val minArray = IntArray(n)
    val maxArray = IntArray(n)

    minArray[0] = nums[0]
    maxArray[n - 1] = nums[n - 1]
    for (i in 1 until n) {
        minArray[i] = min(minArray[i - 1], nums[i])
    }
    for (j in n - 2 downTo 0) {
        maxArray[j] = max(maxArray[j + 1], nums[j])
    }

    for (i in 1 until n - 1) {
        if (minArray[i - 1] < nums[i] && nums[i] < maxArray[i + 1]) return true
    }
    return false
}
```

### Greedy
We choose `first` and `second` greedily to be as small as possible. There are two cases:
1. `third` is greater than `first` and `second`, then we find the triplet.
2. `third` is less than `first` or `second`, then we update `first` or `second` to be as small as possible.

> NOTE: We don't have to shift `first` and `second` when we find out the smaller number than `first` and `second`, because we only care about the relative order of the numbers. The following code is wrong:
> ```kotlin
> if (third < first) {
>     second = first
>     first = third
> }
> ```
> 
> Failed case: `[5, 1, 6]`, `first` will be `1` and `second` will be `5`, `6` will return `true` but that is the wrong answer.
> 
> Or `[3, 5, 1]`

```kotlin
fun increasingTriplet(nums: IntArray): Boolean {
    var first = Int.MAX_VALUE
    var second = Int.MAX_VALUE

    // or 
    // var first = nums[0]
    // var second = Int.MAX_VALUE
    // for (i in 1 until nums.size) {

    for (num in nums) {
        // Find the smallest number
        if (num < first) first = num
        // Find the second smallest number
        // We can't simply use `num < second` only, see `[1, 2, 1, 3]`
        else if (first < num && num < second) second = num
        
        if (first < num && second < num) return true
    }
    return false
}
```

## Failed Cases
1. `[1, 2, 1, 3]`
```python
def increasingTriplet(self, nums: List[int]) -> bool:
    first, second = inf, inf
    for num in nums:
        if num < first:
            first = num
        elif num < second: # Not `first < num < second`
            second = num

        if first < second < num:
            return True
    return False
```