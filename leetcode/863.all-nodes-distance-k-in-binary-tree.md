## [863. All Nodes Distance K in Binary Tree](https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/)

### DFS
```kotlin
class Solution {

    private val parents = hashMapOf<TreeNode, TreeNode>()

    fun distanceK(root: TreeNode?, target: TreeNode?, k: Int): List<Int> {
        val results = mutableListOf<Int>()
        if (root == null) return results
        if (k == 0) {
            results.add(target!!.`val`)
            return results
        }

        findParent(root)

        // Node with distance
        val stack = Stack<Pair<TreeNode, Int>>()
        val visited = hashSetOf<Int>()
        
        if (target != null) stack.push(target to 0)
        while (!stack.isEmpty()) {
            val pair = stack.pop()
            val node = pair.first
            val distance = pair.second
            
            // We have to prevent visting the same node again
            if (visited.contains(node.`val`)) continue
            else visited.add(node.`val`)
            
            if (k == distance) {
                results.add(node.`val`)
            } else if (distance < k) { 
                if (node.left != null) stack.push(node.left!! to distance + 1)
                if (node.right != null) stack.push(node.right!! to distance + 1)
                if (node != root) {
                    stack.push(parents[node]!! to distance + 1)
                }
            }
        }
        return results
    }

    private fun findParent(node: TreeNode) {
        if (node.left == null && node.right == null) return
        if (node.left != null) {
            parents[node.left!!] = node
            findParent(node.left!!)
        }
        if (node.right != null) {
            parents[node.right!!] = node
            findParent(node.right!!)
        }
    }
}
```

### BFS
```kotlin
private val parents = hashMapOf<TreeNode, TreeNode>()
private val results = mutableListOf<Int>()

fun distanceK(root: TreeNode?, target: TreeNode?, k: Int): List<Int> {
    if (root == null || target == null) return results
    findParent(root, target)

    var distance = 0
    val queue = ArrayDeque<TreeNode>()
    val visited = hashSetOf<TreeNode>()
    queue.add(target)
    visited.add(target)
    while (queue.isNotEmpty() && distance <= k) {
        val size = queue.size
        for (i in 0 until size) {
            val node = queue.removeFirst()
            if (distance == k) {
                results.add(node.`val`)
            }
            
            if (node.left != null && !visited.contains(node.left)) {
                queue.addLast(node.left)
                visited.add(node.left)
            }
            if (node.right != null && !visited.contains(node.right)) {
                queue.addLast(node.right)
                visited.add(node.right)
            }
            if (parents.containsKey(node) && !visited.contains(parents[node]!!)) {
                queue.addLast(parents[node]!!)
                visited.add(parents[node]!!)
            }
        }
        distance++
    }
    return results
}

private fun findParent(root: TreeNode?, target: TreeNode?) {
    if (root == null) return
    val queue = ArrayDeque<TreeNode>()
    queue.addLast(root)
    while (queue.isNotEmpty() && !parents.containsKey(target)) {
        val node = queue.removeFirst()
        
        if (node.left != null) {
            parents[node.left] = node
            queue.addLast(node.left)
        }
        if (node.right != null) {
            parents[node.right] = node
            queue.addLast(node.right)
        }
    }
}
```