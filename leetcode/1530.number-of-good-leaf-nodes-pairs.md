# [1530. Number of Good Leaf Nodes Pairs](https://leetcode.com/problems/number-of-good-leaf-nodes-pairs/description/)

## BFS on Graph
We can build a graph from tree, then start to traverse from each leaf node to find the distance between leaf nodes.

```kotlin
fun countPairs(root: TreeNode?, distance: Int): Int {
    if (root == null) return 0
    val graph = HashMap<TreeNode, HashSet<TreeNode>>()
    val leafNodes = HashSet<TreeNode>()
    buildGraph(root, null, graph, leafNodes)

    var pairs = 0
    for (leaf in leafNodes) {
        val queue = ArrayDeque<TreeNode>()
        val visited = HashSet<TreeNode>()
        queue.addLast(leaf)
        visited.add(leaf)
        var currentDistance = 0
        while (queue.isNotEmpty()) {
            val size = queue.size
            repeat(size) {
                val node = queue.removeFirst()
                // It's a leaf node, and it's not the same leaf node.
                if (node in leafNodes && node != leaf) {
                    pairs++
                }
                graph[node]?.forEach { adj ->
                    if (adj !in visited) {
                        queue.addLast(adj)
                        visited.add(adj)
                    }
                }
            }   
            currentDistance++
            if (currentDistance > distance) break
        }
    }
    return pairs / 2
}

private fun buildGraph(root: TreeNode?, parent: TreeNode?, graph: HashMap<TreeNode, HashSet<TreeNode>>, leafNodes: HashSet<TreeNode>) {
    if (root == null) return
    if (root.left == null && root.right == null) {
        leafNodes.add(root)
    }

    if (root !in graph) graph[root] = HashSet<TreeNode>()
    if (parent != null) graph[root]!!.add(parent)
    if (root.left != null) {
        graph[root]!!.add(root.left)
        buildGraph(root.left, root, graph, leafNodes)
    }
    if (root.right != null) {
        graph[root]!!.add(root.right)
        buildGraph(root.right, root, graph, leafNodes)
    } 
}
```

- **Time Complexity**: `O(L * N)`, where `L` is the number of leaf nodes and `N` is the number of nodes in the tree. In worst case, `L` can be `O(N)` (when tree is a path), making it `O(N²)`.
  - Building the graph: `O(N)` - we visit each node once
  - For each leaf node: `O(N)` BFS traversal (in worst case)
  - Total: `O(L * N)` where `L` is the number of leaf nodes
- **Space Complexity**: `O(N)`, where `N` is the number of nodes in the tree.
  - Graph representation: `O(N)` - each node stores its neighbors
  - Queue and visited set: `O(N)` in worst case
  - Leaf nodes set: `O(L) ≤ O(N)`

## Postorder with Distance Array
We have to keep track of the number of leaf nodes with a particular distance for each root node.

> We can think that a parent node receives the distance list of children, then every parent node will validate the condition of left_distance + right_distance <= distance. The base case: When reach to leaf node, we return [1].

```kotlin
private var pairs = 0

fun countPairs(root: TreeNode?, distance: Int): Int {
    dfs(root, distance)
    return pairs
}

// Index i = distance, value = number of leaf nodes with distance i
// distance[0] = 2 means there are 2 leaf nodes with distance 0.
// distance[1] = 3 means there are 3 leaf nodes with distance 1.
// so on... 
private fun dfs(root: TreeNode?, distance: Int): IntArray {
    val leafDistances = IntArray(distance + 1)
    if (root == null) return leafDistances

    if (root.left == null && root.right == null) {
        leafDistances[1] = 1
        return leafDistances
    }
    val leftDistances = dfs(root.left, distance)
    val rightDistances = dfs(root.right, distance)
    for (left in 1..distance) {
        for (right in 1..distance) {
            if (left + right <= distance) {
                pairs += leftDistances[left] * rightDistances[right]
            }
        }
    }
    for (d in 1 until distance) {
        leafDistances[d + 1] = leftDistances[d] + rightDistances[d]
    }
    return leafDistances
}

- **Time Complexity**: `O(N * D²)`, where `N` is the number of nodes in the tree and `D` is the distance.
  - We visit each node once: `O(N)`
  - At each internal node, we have nested loops: `O(D²)` to check all distance combinations
  - Total: `O(N * D²)`
- **Space Complexity**: `O(H * D)`, where `H` is the height of the tree and `D` is the distance.
  - Recursion stack: `O(H)` where `H` is the height of the tree
  - Each recursive call creates an `IntArray` of size `D+1`: `O(D)`
  - Total: `O(H * D)`
```

## Postorder with HashMap
```kotlin
// Or we can use a map to store the distance of leaf nodes, then we can calculate the distance of leaf nodes from root node by postorder traversal.
// Map: TreeNode -> Distance, representing the distance between leaf node and root node.
private fun dfs(root: TreeNode?, distance: Int): HashMap<TreeNode, Int> {
    val map = HashMap<TreeNode, Int>()
    if (root == null) return map
    if (root.left == null && root.right == null) {
        map[root] = 0
        return map
    }

    val leftMap = dfs(root.left, distance)
    val rightMap = dfs(root.right, distance)

    for ((k, v) in leftMap) {
        leftMap[k] = v + 1
    }
    for ((k, v) in rightMap) {
        rightMap[k] = v + 1
    }

    for ((leftNode, leftDistance) in leftMap) {
        for ((rightNode, rightDistance) in rightMap) {
            if (leftDistance + rightDistance <= distance) count++
        }
    }

    for ((k, v) in rightMap) {
        leftMap[k] = v
    }
    return leftMap
}

- **Time Complexity**: `O(N * L²)`, where `N` is the number of nodes and `L` is the number of leaf nodes. In worst case, `L` can be `O(N)` (when tree is a path), making it `O(N³)`.
  - We visit each node once: `O(N)`
  - At each internal node, we iterate through all leaf nodes from left and right subtrees: `O(L²)`
  - Total: `O(N * L²)`
  - In worst case (path tree), `L = O(N)`, making it `O(N³)`
- **Space Complexity**: `O(N)`, where `N` is the number of nodes in the tree.
  - Recursion stack: `O(H)` where `H` is the height of the tree
  - HashMap storage: `O(L) ≤ O(N)` for storing leaf nodes and their distances
  - Total: `O(N)`
```

- **Time Complexity**: `O(N * L²)`, where `N` is the number of nodes and `L` is the number of leaf nodes. In worst case, `L` can be `O(N)` (when tree is a path), making it `O(N³)`.
  - We visit each node once: `O(N)`
  - At each internal node, we iterate through all leaf nodes from left and right subtrees: `O(L²)`
  - Total: `O(N * L²)`
  - In worst case (path tree), `L = O(N)`, making it `O(N³)`
- **Space Complexity**: `O(N)`, where `N` is the number of nodes in the tree.
  - Recursion stack: `O(H)` where `H` is the height of the tree
  - HashMap storage: `O(L) ≤ O(N)` for storing leaf nodes and their distances
  - Total: `O(N)`

> [Good explanation](https://leetcode.cn/problems/number-of-good-leaf-nodes-pairs/solutions/347670/dfsshen-du-yi-ci-bian-li-python3-by-dz-lee/) for hash map solution.