## [75. Sort Colors](https://leetcode.com/problems/sort-colors)

### Counting Sort
```kotlin
fun sortColors(nums: IntArray): Unit {
    val counts = IntArray(3)
    for (i in 0 until nums.size) {
        counts[nums[i]]++
    }
    var i = 0
    while (i < nums.size) {
        if (i < counts[0]) nums[i] = 0
        else if (i in counts[0] until counts[0] + counts[1]) nums[i] = 1
        else nums[i] = 2

        i++
    }
}
```

### Sort By Partition
Idea from the partition of [Quick Sort](../topics/sorting.md#quick-sort), we will partition all 0s to the left part, all 2s to the right part, then all 1s will be in the middle.

We define the `p0`, `p2` such that:
* The position [0 ~ p0] (`A[0:p0]`) are 0s.
* The partition [p2 ~ n - 1] are 2s.

Then we encounter `0`, we put it into the left part, and put `2` to the right part.

```js
0, 0, ..., 0 | ??? | 2, 2, 2..., 2 |
0         p0        p2          n-1
```

```kotlin
fun sortColors(nums: IntArray): Unit {
    //      [1, 2, 0, 2, 0, 1]
    //  p0                     p2
    // [0 ~ p0] are all 0s
    // [p2 ~ n - 1] are all 2s
    var p0 = -1
    var p2 = nums.size

    // [0, p0] == 0 / ??? / [p2, n -1] == 2
    var i = 0
    while (i < p2) {
        when (nums[i]) {
            0 -> {
                // Increase the range of 0s
                p0++
                nums.swap(i, p0)
                i++
            }
            1 -> {
                // We just skip it
                i++
            }
            2 -> {
                p2--
                nums.swap(i, p2)
                // The value after swapping might be 2, so we don't 
                // increament i here, continue the while loop to check.
            }
        }
    }
}

private fun IntArray.swap(i: Int, j: Int) {
    val temp = this[i]
    this[i] = this[j]
    this[j] = temp
}
```