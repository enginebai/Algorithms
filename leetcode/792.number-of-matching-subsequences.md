## [792. Number of Matching Subsequences](https://leetcode.com/problems/number-of-matching-subsequences)

### Binary Search


### Hash Table
1. We build a hash table based on the first character of the words: `{'a': ["a", "acd", "ace"], 'b': ["bb"]}`
2. Iterate every character of `s`, find the list based on the starting character and iterate the words from the list:
    1. If the length of word is 1, then we find the subsequence.
    1. If not, we get the substring from the 2nd character and add the substring to hash table based on its first character.

```js
s = "abcde"
words = ["a","bb","acd","ace", "ba", "da"]

// Build the hash table based on the first character of words
a: ["a", "acd", "ace"]
b: ["bb", "ba"]
c: []
d: ["da"]
e: []

// Start iterating every character of s
s = "abcde"
     *
// Find the word list of 'a' key
a: ["a", "acd", "ace"]
     *                 // count + 1
          *            // add "cd" to key 'c'
                 *     // add "ce" to key 'c'
// Hash table becomes:
a: []
b: ["bb", "ba"]
c: ["cd", "ce"]
d: ["da"]
e: []

//-------------------
s = "abcde"
      *
// Find the word list of 'b' key
b: ["bb", "ba"]
     *                 // add "b" to key 'b'
           *           // add "a" to key 'a'
// Hash table becomes:
a: ["a"]
b: ["b"]
c: ["cd", "ce"]
d: ["da"]
e: []

//-------------------
s = "abcde"
       *
// Find the word list of 'c' key
c: ["cd", "ce"]
     *                 // add "d" to key 'd'
           *           // add "e" to key 'e'
// Hash table becomes:
a: ["a"]
b: ["b"]
c: []
d: ["da", "d"]
e: ["e"]

//-------------------
s = "abcde"
        *
// Find the word list of 'c' key
d: ["da", "d"]
     *                 // add "a" to key 'a'
           *           // count + 1
// Hash table becomes:
a: ["a", "a"]
b: ["b"]
c: []
d: []
e: ["e"]

//-------------------
s = "abcde"
         *
// Find the word list of 'c' key
e: ["e"]
     *                 // count + 1
// Hash table becomes:
a: ["a", "a"]
b: ["b"]
c: []
d: []
e: []
```

> [Nice explanation with visualization](https://leetcode.com/problems/number-of-matching-subsequences/solutions/1290406/c-java-python-process-by-bucket-picture-explain-o-n-s/)

```kotlin
fun numMatchingSubseq(s: String, words: Array<String>): Int {
    val wordMap = hashMapOf<Char, ArrayDeque<String>>()
    for (c in 'a'..'z') {
        wordMap[c] = ArrayDeque<String>()
    }
    for (word in words) {
        val first = word[0]
        wordMap[first]!!.addLast(word)
    }
    var count = 0
    for (c in s) {
        val wordSize = wordMap[c]!!.size
        for (i in 0 until wordSize) {
            val word = wordMap[c]!!.removeFirst()
            if (word.length == 1) count++
            else {
                val substring = word.substring(1)
                wordMap[substring[0]]!!.addLast(substring)
            }
        }
    }
    return count
}
```

* **Time Complexity**: `O(w + s)`.
* **Space Complexity**: `O(w)` for storing all the words.