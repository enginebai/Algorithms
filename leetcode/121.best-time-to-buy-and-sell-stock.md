## [121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)

### Greedy
We're going to find minimium price to buy and calculate max profit for every day.

|           | Init | 7 | 1 | 5 | 3 | 6 | 4 |
|-----------|------|---|---|---|---|---|---|
| minPrice  | oo   | 7 | 1 | 1 | 1 | 1 | 1 |
| maxProfit | 0    | 0 | 0 | 4 | 4 | 5 | 5 |

```kotlin
fun maxProfit(prices: IntArray): Int {
    var min: Int? = null
    var profit = 0
    for (i in 0 until prices.size) {
        if (min == null) {
            min = prices[i]
        } else {
            if (prices[i] < min) min = prices[i]
            val currentProfit = prices[i] - min
            profit = if (currentProfit > profit) currentProfit else profit
        }
    }
    return profit
}
```

* **Time Complexity**: `O(n)`.
* **Space Complexity**: `O(1)`.

### Dynamic Programming
There are two states: `Cash` (you don't buy stock or sell back to cash out) or `Stock` (you bought it or cash in), and there are two actions for the two states on each day: you either can do nothing or buy/sell the stock (depend on whether you bought before or not), so the state machine for stock transaction on `i-th` day is
![](../media/121.best-time-to-buy-and-sell-stock.png)

* If you stay in `Cash` state on `i - 1` day, then you can do nothing (`Cash`) or buy stock on `i` day (`Stock`).
* So on for `Stock` state.

The max profit is the `Cash` state on `n-th` day, and we have calculate the two states with different available actions from the first day to `n-th` day.

![](../media/121.best-time-to-buy-and-sell-stock2.png)

So we can use DP to transfer the state machine to find the max profit:
* We define our `dp[i][0]` and `dp[i][1]` as the max profit for `Cash` and `Stock` states on `i-th` day.
* For `Cash` state, we either can do nothing or sell.
```kotlin
dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])
         = max( Do Nothing , Sell Stock )
```
* For `Stock` state, we either can do nothing or buy stock (we have to pay the cash for the price)
```kotlin
dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])
         = max( Do Nothing , Buy Stock )
```
* The base cases for the two states would be `0` (We don't own stock, the profit is 0) and `-prices[0]` (We own the stock, but the profit is `-prices[0]`, we can't cash out)

```kotlin
fun maxProfit(prices: IntArray): Int {
    val n = prices.size
    val dp = Array(prices.size) { _ -> IntArray(2) }
    // The max profit for Cash state is 0
    dp[0][0] = 0
    // The max profit for Stock state is the amount we pay for the stock
    dp[0][1] = -prices[0]
    for (i in 1 until prices.size) {
        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])

        // It should be max(dp[i - 1][1], dp[i - 1][0] - prices[i])
        // We can only buy once, so the dp[i - 1][0] is always 0 (always buy stock at i-th price)
        dp[i][1] = max(dp[i - 1][1], 0 - prices[i])
    }
    return dp[n - 1][0]
}
```

```js
Day i       1	2	3	4	5	6	
Price i     7	1	5	3	6	4
dp[i][0]    0	0	4	4	5	5	
dp[i][1]    -7	-1	-1	-1	-1	-1	
```

### Brute Force
```kotlin
fun maxProfit(prices: IntArray): Int {
    if (prices.size <= 1) return 0
    if (prices.size == 2) {
        val diff = prices[1] - prices[0]
        return if (diff > 0) diff else 0
    }
    var maxProfit = 0
    for (buy in 0 until prices.size) {
        for (sell in buy + 1 until prices.size) {
            val diff = prices[sell] - prices[buy]
            if (diff > 0) {
                maxProfit = max(maxProfit, diff)
            }
        }
    }       
    return maxProfit
}

private fun max(n1: Int, n2: Int) = if (n1 > n2) n1 else n2
```

* **Time Complexity**: `O(n^2)`.
* **Space Complexity**: `O(1)`.