## [2874. Maximum Value of an Ordered Triplet II](https://leetcode.com/problems/maximum-value-of-an-ordered-triplet-ii/description/)

To find the maximum value of `(nums[i] - nums[j]) * nums[k]` where `i < j < k`, we try to find the maximum of `nums[i]` from left and `nums[k]` from right. Then we iterate `nums[j]` as minimum to find the global maximum value.

> TODO: There is a better solution with O(1) space complexity.

```python
def maximumTripletValue(self, nums: List[int]) -> int:
    # (A[i] - A[j]) * A[k]
    #  max    min     max
    # (    max    ) * max
    n = len(nums)
    left_max = [0] * n
    right_max = [0] * n
    left_max[0] = nums[0]
    for i in range(1, n):
        left_max[i] = max(left_max[i - 1], nums[i])
    right_max[-1] = nums[-1]
    for i in range(n - 2, -1, -1):
        right_max[i] = max(right_max[i + 1], nums[i])
    
    answer = -inf
    for i in range(1, n - 1):
        answer = max(answer, (left_max[i - 1] - nums[i]) * right_max[i + 1])
    return answer if answer > 0 else 0
```

```kotlin
fun maximumTripletValue(nums: IntArray): Long {
    val n = nums.size
    val leftMax = IntArray(n) { Int.MIN_VALUE }
    val rightMax = IntArray(n) { Int.MIN_VALUE }
    leftMax[0] = nums[0]
    for (i in 1 until n) {
        leftMax[i] = maxOf(leftMax[i - 1], nums[i])
    }
    rightMax[n - 1] = nums[n - 1]
    for (i in n - 2 downTo 0) {
        rightMax[i] = maxOf(rightMax[i + 1], nums[i])
    }
    var result = Long.MIN_VALUE
    for (i in 1 until n - 1) {
        result = maxOf(result, (leftMax[i - 1] - nums[i]).toLong() * rightMax[i + 1])
    }
    return if (result < 0) 0 else result
}
```
* **Time Complexity**: O(n).
* **Space Complexity**: O(n).