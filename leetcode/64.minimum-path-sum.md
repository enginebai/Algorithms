## [64. Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/)

### Top-Down Recursion (TLE)
```kotlin
fun minPathSum(grid: Array<IntArray>): Int {
    return pathSum(grid, grid.size - 1, grid[0].size - 1)
}

private fun pathSum(grid: Array<IntArray>, x: Int, y: Int): Int {
    if (x == 0 && y == 0) return grid[x][y]
    if (x == 0) return pathSum(grid, x, y - 1) + grid[x][y]
    if (y == 0) return pathSum(grid, x - 1, y) + grid[x][y]
    else return min(pathSum(grid, x - 1, y), pathSum(grid, x, y - 1)) + grid[x][y]
}
```

### Top-Down DP
```kotlin
fun minPathSum(grid: Array<IntArray>): Int {
    val dp = Array(grid.size) { _ -> IntArray(grid[0].size) { _ -> -1 } }
    return pathSum(grid, grid.size - 1, grid[0].size - 1, dp)
}

private fun pathSum(grid: Array<IntArray>, x: Int, y: Int, dp: Array<IntArray>): Int {
    if (x == 0 && y == 0) return grid[x][y]
    if (dp[x][y] != -1) return dp[x][y]
    dp[x][y] = 
        if (x == 0) pathSum(grid, x, y - 1, dp) + grid[x][y] 
        else if (y == 0) pathSum(grid, x - 1, y, dp) + grid[x][y] 
        else min(pathSum(grid, x - 1, y, dp), pathSum(grid, x, y - 1, dp)) + grid[x][y]
    return dp[x][y]
}
```

* **Time Complexity**: `O(m*n)`.
* **Space Complexity**: `O(m*n)`

### Bottom-Up DP
```kotlin
fun minPathSum(grid: Array<IntArray>): Int {
    val m = grid.size
    val n = grid[0].size
    val dp = Array(m) { _ -> IntArray(n) }
    
    dp[0][0] = grid[0][0]
    for (i in 1 until m) {
        dp[i][0] = grid[i][0] + dp[i - 1][0]
    }
    for (j in 1 until n) {
        dp[0][j] = grid[0][j] + dp[0][j - 1]
    }
    
    for (i in 1 until m) {
        for (j in 1 until n) {
            dp[i][j] = min(
                dp[i - 1][j] + grid[i][j],
                dp[i][j - 1] + grid[i][j]
            )
        }
    }
    
    return dp[m - 1][n - 1]
}
```
* **Time Complexity**: `O(m*n)`.
* **Space Complexity**: `O(m*n)`

### Bottom-Up DP (Space Optimization)
```kotlin
fun minPathSum(grid: Array<IntArray>): Int {
    val m = grid.size
    val n = grid[0].size
    var result = 0
    var up = IntArray(n)
    var left = 0 
    for (i in 0 until m) {
        for (j in 0 until n) {
            if (i == 0) {
                result = left + grid[i][j]
            } else if (j == 0) {
                result = up[j] + grid[i][j]
            } else {
                result = min(up[j], left) + grid[i][j]
            }
            up[j] = result
            left = result
        }
    }
    return result
}
```

* **Time Complexity**: `O(m*n)`.
* **Space Complexity**: `O(n)`