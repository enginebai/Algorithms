# [380. Insert Delete GetRandom O(1)](https://leetcode.com/problems/insert-delete-getrandom-o1/description/)

## Hash Table + List
* To support random access in `O(1)` time, we can use array / list, but we can't check if the element is present in `O(1)` time.
* To support check if the element is present in `O(1)` time, we can use hash table, but we can't support random access in `O(1)` time.

In order to support random access and check present in `O(1)` time, we can use both data structures together.

## Removal in `O(1)` time
There is an important technique to support removal in `O(1)` time: **Swap and remove the last element**, but the order of swap and remove is important.

### Key Steps
1. Delete the target index from map first.
2. If the target index is not the last index, move the last element to the target index and update the index of the last element in the map.
3. Remove the last element from the list.

Why this order?
* It's safe when `target index == last index`, because we don't need to swap.
* If `target index != last index`, `lastValue` is guaranteed **different** from `val`, so removing `val` first is safe.

> * 我們都是先移除目標位置，保證 map 在接下來任何操作之前都已經是乾淨的。然後再判斷要不要跟最後的位置交換？最後一步才是把目標值從列表移除。
> * 重點在於 target index 和 last index 是否相同，這題不會出現 target value == last value 的情況，而 381 題會出現，但是大原則都是判斷 index 是否相同，因為 remove 是要看「位置」交換而不是「值」。

One line to remember: **“Delete target index → (if needed) move last & fix moved mappings → pop last.”** This single principle applies to both 380 and 381 and shields you from the classic pitfalls.

```kotlin
class RandomizedSet() {

    private val values = mutableListOf<Int>()
    private val valueIndexMap = HashMap<Int, Int>()

    fun insert(`val`: Int): Boolean {
        if (`val` in valueIndexMap) return false
        values.add(`val`)
        valueIndexMap[`val`] = values.lastIndex
        return true
    }

    fun remove(`val`: Int): Boolean {
        val index = valueIndexMap[`val`] ?: return false

        // 1. Remove the target index from map first.
        valueIndexMap.remove(`val`)

        // 2.Check if we should swap the last element with the target element.
        val lastIndex = values.lastIndex
        if (index != lastIndex) {
            val lastValue = values.last()
            values[index] = lastValue
            valueIndexMap[lastValue] = index
        }
        // 3. Pop the last element from the list.
        values.removeAt(lastIndex)
        return true
    }

    fun getRandom(): Int {
        val randomIndex = Math.random() * values.size
        return values[randomIndex.toInt()]
    }
}
```

## WA
The following `remove()` is not correct. It failed at the case when we have single element in the set or the value to remove is the last element in the set.
```js
var set = new RandomizedSet()
set.insert(1)
set.remove(1)
set.insert(1) // Actual false, but expected true.
```
```kotlin
class RandomizedSet() {

    // Same as the AC solution.
    private val values = mutableListOf<Int>()
    private val valueIndexMap = HashMap<Int, Int>()

    // Return true if not exist, false if exist.
    fun insert(`val`: Int): Boolean {
        if (`val` in valueIndexMap) return false
        values.add(`val`)
        valueIndexMap[`val`] = values.size - 1
        return true
    }

    // Different from the AC solution.
    fun remove(`val`: Int): Boolean {
        val index = valueIndexMap[`val`] ?: return false

        // Remove the old mapping of the deleted value.
        valueIndexMap.remove(`val`)

        // -------- Begin of swap to remove the value --------
        val lastIndex = values.lastIndex
        val lastValue = values.last()
        
        // Swap the value to remove with the last value.
        values[index] = lastValue 

        // Update the value index of the swapped value.
        // Bug: If `val == lastValue`, it will be added back to the map after we remove the value.
        // But it should be removed from the map.
        valueIndexMap[lastValue] = index

        // Drop the last element in O(1) time after swapping.
        values.removeAt(lastIndex)
        // -------- End of swap to remove the value --------
        
        return true
    }

    // Same as the AC solution.
    fun getRandom(): Int {
        val random = Math.random() * values.size
        return values[random.toInt()]
    }
}
```

### Fix
Correct `remove()` implementation: **We swap if and only if they are different**.

> There are some solutions that do not check, they just swap and remove the last element. This is safe even if we remove the last element in the list, if we remove:
>   * Not the last element → it swaps and pop.
>   * The last element → overwrite self and reassign the same index.