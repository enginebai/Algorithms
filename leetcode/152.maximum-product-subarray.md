## [152. Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/)

### Dynamic Programming
Similar idea from [53. Maximum Subarray](../leetcode/53.maximum-subarray.md), but we store the local maximum and minimum simultaneously since the local minimum * next negative number might be the next maximum. (For example, `[-2, 3, -4]`, it will be `3` if we transit the local max only, however, the answer is `24`)

```kotlin
fun maxProduct(nums: IntArray): Int {
    val localMax = IntArray(nums.size)
    val localMin = IntArray(nums.size)
    var globalMax = nums[0]
    localMax[0] = nums[0]
    localMin[0] = nums[0]
    for (i in 1 until nums.size) {
        val current = nums[i]
        val productOfPreviousMax = current * localMax[i - 1]
        val productOfPreviousMin = current * localMin[i - 1]
        
        localMax[i] = max(max(current, productOfPreviousMax), productOfPreviousMin)
        localMin[i] = min(min(current, productOfPreviousMax), productOfPreviousMin)
        
        globalMax = max(localMax[i], globalMax)
    }
    return globalMax
}
```

### Space Optimization
```kotlin
fun maxProduct(nums: IntArray): Int {
    if (nums.size == 1) return nums[0]
    var globalMax = nums[0]
    var maxProduct = nums[0]
    var minProduct = nums[0]
    for (i in 1 until nums.size) {
        val current = nums[i]
        val currentMaxProduct = maxProduct * current
        val currentMinProduct = minProduct * current

        maxProduct = max(
            current,
            max(currentMaxProduct, currentMinProduct)
        )
        minProduct = min(
            current,
            min(currentMaxProduct, currentMinProduct)
        )
        globalMax = max(globalMax, maxProduct)
    }
    return globalMax
}
```