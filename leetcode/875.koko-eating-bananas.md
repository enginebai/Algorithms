## [875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/description/)

**Idea!!** As the eating speed is slower, the required hours is longer, and vice versa. This forms a monotonic function, so we can use binary search to find the minimum speed. **Monotonicity is the key to use binary search**, we **guess** the speed and check if it's possible to eat all piles within `H` hours. 

What is the search range? The minimum speed is 1, and the maximum speed is the maximum of piles because Koko choose only one pile to eat at a time. This is the binary search on value.

```kotlin
class Solution {
    fun minEatingSpeed(piles: IntArray, h: Int): Int {
        var left = 1
        var right = getMax(piles)

        // We can't use this because the sum of piles divided by speed, because
        // Koko can only eat one pile at a time.
        // var sum = 0
        // for (p in piles) sum += p

        while (left <= right) {
            val middle = left + (right - left) / 2
            if (canEatAll(piles, middle, h)) {
                right = middle - 1
            } else {
                left = middle + 1
            }
        }
        return left
    }

    private fun canEatAll(piles: IntArray, speed: Int, limit: Int): Boolean {
        // To convert to long in case of overflow.
        var hours = 0L
        for (p in piles) {
            hours += p / speed

            // If current pile is not divisible by speed, we need one more hour.
            if (p % speed != 0) hours++
        }
        return hours <= limit
    }

    private fun getMax(piles: IntArray): Int {
        var max = piles[0]
        for (p in piles) {
            max = maxOf(max, p)
        }
        return max
    }
}

* **Time Complexity:** `O(n * lg max(n))` where `n` is the number of piles.
* **Space Complexity:** `O(1)`.