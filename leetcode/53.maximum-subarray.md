## [53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)

### Dynamic Programming (Kadane's Algorithm)
```kotlin
fun maxSubArray(nums: IntArray): Int {
    if (nums.size == 1) return nums[0]
    val dp = IntArray(nums.size)
    dp[0] = nums[0]
    var max = nums[0]
    for (i in 1 until nums.size) {
        // We keep appending the i-th number or restart a totally new number.
        dp[i] = max(dp[i - 1] + nums[i], nums[i])
        max = max(max, dp[i])
    }
    return max
}
```
* **Time Complexity**: `O(n)`.
* **Space Complexity**: `O(n)`.

With space optimization:
```kotlin
fun maxSubArray(nums: IntArray): Int {
    if (nums.size == 1) return nums[0]
    var globalMax = nums[0]
    var previousMax = nums[0]
    for (i in 1 until nums.size) {
        previousMax = max(previousMax + nums[i], nums[i])
        globalMax = max(globalMax, previousMax)
    }
    return globalMax
}
```

#### References
* [Nice explanation for how to deriving to DP](https://leetcode.cn/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/)
* https://medium.com/@rsinghal757/kadanes-algorithm-dynamic-programming-how-and-why-does-it-work-3fd8849ed73d

### Brute Force
```kotlin
fun maxSubArray(nums: IntArray): Int {
    var max = Int.MIN_VALUE
    for (i in 0 until nums.size) {
        for (j in i until nums.size) {
            var sum = 0
            for (k in i..j) {
                sum += nums[k]
            }
            if (sum > max) {
                max = sum
            }
        }
    }
    return max
}
```

* **Time Complexity**: `O(n^3)`.
* **Space Complexity**: `O(1)`.

----
### My DP Fist Attempt (WA)

> This is the solution for Maximum Subsequence, not subarray!!

```kotlin
fun maxSubArray(nums: IntArray): Int {
    val dp = Array(nums.size) { _ -> IntArray(nums.size) }
    
    for (i in 0 until nums.size) {
        dp[i][i] = nums[i]
    }
    
    for (i in nums.size - 1 downTo 0) {
        for (j in i + 1 until nums.size) {
            if (i == j) continue
            dp[i][j] = max(
                dp[i + 1][j - 1] + nums[i] + nums[j],
                dp[i + 1][j] + nums[i]
            )
            dp[i][j] = max(
                dp[i][j],
                dp[i][j - 1] + nums[j]
            )
        }
    }
    return dp[0][nums.size - 1]
}
```