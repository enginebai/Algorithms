# [2226. Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/description/)

## Binary Search
There are some key constraints in the problem:
* You can divide each pile into any number of sub piles, but you cannot merge two piles together. 
```js
candies = [6, 8]
           ^
// We can take `6` to one child or `3 + 3` to two children.
// But we can't take `6 + 8` to one child by merging two piles.
```
* Each child gets the same number of candies. 
* Each child can take at most one pile of candies and some piles of candies may go unused. `[8] = [3][3]` to two children (`2` are unsed), it can't be `[3][3][2]` to 3 children.

----
For candies `[2, 5]`, and `k = 2` children:
```js
candies = 1 if [1 | 1]       // valid
candies = 2 if [2 | 2, 2]    // valid, maximum
candies = 3 if [X | 3]       // invalid
candies = 4 if [X | 4]       // invalid
candies = 5 if [X | 5]       // invalid
candies = 6 if [X | X]       // invalid
```

* When `k == 1`, we distribute `max(candies)` to the child.
* When `k == sum(candies)`, we distribute only `1` to each child.
* When `k` is more than total candies, we can't distribute any candy to each child, since every child must get the same number of candies, it can't be some get candy but some dont'.

So the possible answer must be in the range `[0, max(candies)]`.

As the above example, if we can allocate `x` candies to `k` children, we can allocate `x - 1`, `x - 2`, ... candies to `k` children. If we can't allocate `x` candies to `k` children, we can't allocate `x + 1`, `x + 2`, ... candies to `k` children. This exhibits the **monotonicity** characteristic.

* If `x` is feasible, all values `< x` are also feasible.
* If `x` is too large, we cannot distribute to `k` children.
* If `x` is small enough, we can distribute successfully.

```js
[O, O, O, O, X, X, X, ...]
          ^
          The maximum candies we can allocate to k children
```

So we can use binary search to find the maximum candies we can allocate to `<= k` children.

> Why allowing `< k` children at some amount? It's allowed becase we can increase the amount until we reach the maximum candies we can allocate to `k` children. The more candies we allocate, the less children we can allocate to, that's why `< k` is also acceptable.

```kotlin
fun maximumCandies(candies: IntArray, k: Long): Int {
    var max = Int.MIN_VALUE
    for (c in candies) {
        max = maxOf(max, c)
    }

    // Pay attention to the lower bound, 0 is acceptable answer but we can't used 
    // in binary search because it leads to the error divided by 0 when calculating
    // the children count.
    var left = 1 
    var right = max
    while (left <= right) {
        val middle = left + (right - left) / 2
        if (canAllocated(candies, k, middle)) {
            left = middle + 1
        } else {
            right = middle - 1
        }
    }
    // right will become 0 if there is no candies to distribute.
    //   X X X X X
    // ^ right
    return right
}

private fun canAllocated(candies: IntArray, k: Long, value: Int): Boolean {
    var children = 0L
    for (c in candies) {
        children += (c / value).toLong()
    }
    return k <= children
}
```

* **Time Complexity:** `O(n * log(max(candies)))`, where `n` is the size of the candies array.
* **Space Complexity:** `O(1)`.