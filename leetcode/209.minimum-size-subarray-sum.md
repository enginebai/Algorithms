## [209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/)

## Sliding Window
* The window `[start..end]` maintains the subarray that its sum >= `target`.
* We keep starting index fixed and keep expanding the ending index until the sum of `[start..end]` >= `target`.
* Then we reduce the window size by increasing the starting index until `[start..end]` < `target` so that we can get the **minimum** size of subarray that meets the requirement.

```kotlin
fun minSubArrayLen(target: Int, nums: IntArray): Int {
    var minLength = Int.MAX_VALUE
    var start = 0
    var end = 0
    var currentSum = 0
    while (end < nums.size) {
        currentSum += nums[end]
        while (currentSum - nums[start] >= target) {
            currentSum -= nums[start]
            start++
        }

        if (currentSum >= target) {
            val currentLength = end - start + 1
            minLength = if (currentLength < minLength) currentLength else minLength
        }
        end++
    }
    return if (minLength == Int.MAX_VALUE) 0 else minLength
}
```

* **Time Complexity**: `O(n)`, we move ending index and then starting index, that just scaned through array.
* **Space Complexity**: `O(1)` for no extra space.
