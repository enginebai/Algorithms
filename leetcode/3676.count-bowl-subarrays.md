# [3676. Count Bowl Subarrays](https://leetcode.com/problems/count-bowl-subarrays/)

## Monotonic Stack
We are going to find the bowl-shaped subarray.

```js
*      
*   * 
* * * 
4 1 2

        *
*       *
* * * * *
2 1 1 1 3
```

We can iterate each element as the lowest position, then aim to find the previous and next greater element as the left and right boundary. We can use monotonic decreasing stack to find the next greater element.

```js
5, 3, 1, 4
         i

stack = [5, 3, 1] < 4
```

After popping the smaller elements from stack, we update the right boundary for **the popped element**. At the same time, we can update the left boundary for **the current element**:

```js
stack = [5, 3, 1] < 4

pop 1, 1.right = 4
pop 3, 3.right = 4

stack = [5] < 4? No, stop popping
4.left = 5 // We have to update the left boundary for the current element.
```

After iteration, we can find the left and right boundary for each element (`-1` indicates no boundary found), then we can count the number of bowl-shaped subarrays.

```js
// Example 1
L   _  _  5  3  5
R   5  _  4  4  _
   [2, 5, 3, 1, 4]
                i
stack = [5, 4]

// Example 2
L      _  5  5  5  5
R      _  2  3  4  _
      [5, 1, 2, 3, 4]
                   i
stack = [5, 4]
```

```kotlin
fun bowlSubarrays(nums: IntArray): Long {
    val n = nums.size
    if (n < 3) return 0L
    val leftBoundary = IntArray(n) { -1 }
    val rightBoundary = IntArray(n) { -1 }
    var count = 0L
    val stack = ArrayDeque<Int>() // monotonic decreasing 5, 4, 3 < 6
    for (i in nums.indices) {
        while (stack.isNotEmpty() && nums[stack.last()] < nums[i]) {
            val index = stack.removeLast()
            // Find the right boundary for the popped element.
            rightBoundary[index] = i
        }
        // Update the left boundary for the current element.
        if (stack.isNotEmpty()) {
            leftBoundary[i] = stack.last()
        }
        stack.addLast(i)
    }
    for (i in 0 until n) {
        val left = leftBoundary[i]
        val right = rightBoundary[i]
        if (left != -1 && right != -1) {
            count++
        }
    }
    return count
}
```

* **Time Complexity**: `O(n)`, where `n` is the length of the input array.
* **Space Complexity**: `O(n)`, where `n` is the length of the input array.