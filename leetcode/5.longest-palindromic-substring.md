## [5. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/)

### Brute Force
```kotlin
fun longestPalindrome(s: String): String {
    var results = ""
    for (i in 0 until s.length) {
        for (j in i until s.length) {
            val substring = s.substring(i, j)
            if (isPalindrome(substring)) {
                if (substring.length > results) {
                    results = substring
                }
            }
        }
    }
}

private fun isPalindrome(s: String): Boolean {
    var left = 0
    var right = s.length - 1
    while (left < right) {
        if (s[left] != s[right]) return false
        left++
        right--
    }
    return true
}
```

* **Time Complexity**: `O(n^3)`, `O(n^2)` for two for-loops, `O(n)` to check if the substring is palindrome.
* **Space Complexity**: `O(1)`.

### Dynamic Programming
It's simiar to [516. Longest Palindromic Subsequence](../leetcode/516.longest-palindromic-subsequence.md), we can use `dp[i][j]` to represent the state (if substring is palindrome) of `s[i:j]` substring.

* Base cases:
```js
// The character itself is palindrome
dp[i][i] = true

// The length of substring is two
dp[i][i + 1] = (s[i] == s[i + 1])
```

* Recursive cases:
```js
dp[i][j] = dp[i + 1][j - 1] && s[i] == s[j]
```

```kotlin
fun longestPalindrome(s: String): String {
    val len = s.length
    val dp = Array(len) { _ -> BooleanArray(len)}
    
    // Base case:
    // We will setup in the for loop below, so we don't do here.
    // Or we can do here, and REMEMBER to skip below.
    //
    // for (i in 0 until len) {
    //     dp[i][i] = true
    //     if (i + 1 < len) {
    //         dp[i][i + 1] = (s[i] == s[i + 1])
    // }
    
    // We will use start + offset to calculate the substring.
    var resultStart = 0
    var resultLength = 1

    for (i in len - 1 downTo 0) {
        for (j in i + 1 until len) {
            // j - i < 2 means the length of substring is 1 or 2, this is 
            // the base cases.
            dp[i][j] = (dp[i + 1][j - 1] || j - i < 2) && s[i] == s[j]

            // If the current substring is palindrome, we update the longest palindrome result
            if (dp[i][j] == true) {
                val currentLength = j - i + 1
                if (currentLength > resultLength) {
                    resultLength = currentLength
                    resultStart = i
                }                                        
            }
        }
    }
    
    return s.substring(resultStart, resultStart + resultLength)
}   
```
* **Time Complexity**: `O(n^2)`.
* **Space Complexity**: `O(n^2)`.

### Expand Around Center
For every character, we expand the string to left/right at the same time and see if it's palindrome.

```kotlin
fun longestPalindrome(s: String): String {
    var maxPalindrome = ""
    for (i in 0 until s.length) {
        // check odd length case, like "aba"
        var currentPalindrome = findPalindromeSubstring(s, i, i)
        if (maxPalindrome.length < currentPalindrome.length) {
            maxPalindrome = currentPalindrome
        }
        // check even length case, like "abba", and 
        // we extend from the first "b" from odd length case, it will
        // fail, but it's valid palindrome.
        currentPalindrome = findPalindromeSubstring(s, i, i + 1)
        if (maxPalindrome.length < currentPalindrome.length) {
            maxPalindrome = currentPalindrome
        }
    }
    return maxPalindrome
}

private fun findPalindromeSubstring(s: String, start: Int, end: Int): String {
    var i = start
    var j = end
    if (s.isEmpty() || i > j) return ""
    // Keep expand the palindrome
    while (i >= 0 && j < s.length && s[i] == s[j]) {
        i--
        j++
    }
    return s.slice(i + 1 until j)
}
```

* **Time Complexity**: `O(n^2)`.
* **Space Complexity**: `O(1)`.

#### References
* https://leetcode.com/problems/longest-palindromic-substring/discuss/2954/Python-easy-to-understand-solution-with-comments-(from-middle-to-two-ends).