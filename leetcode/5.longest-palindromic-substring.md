## [5. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/)

### Brute Force
```kotlin
fun longestPalindrome(s: String): String {
    var results = ""
    for (i in 0 until s.length) {
        for (j in i until s.length) {
            val substring = s.substring(i..j)
            println("$i, $j, $substring")
            if (isPalindrome(substring)) {
                if (substring.length > results.length) {
                    results = substring
                }
            }
        }
        println()
    }
    return results
}

private fun isPalindrome(s: String): Boolean {
    var left = 0
    var right = s.length - 1
    while (left < right) {
        if (s[left] != s[right]) return false
        left++
        right--
    }
    return true
}
```

* **Time Complexity**: `O(n^3)`, `O(n^2)` for two for-loops, `O(n)` to check if the substring is palindrome.
* **Space Complexity**: `O(1)`.

### Dynamic Programming
It's simiar to [516. Longest Palindromic Subsequence](../leetcode/516.longest-palindromic-subsequence.md), we can use `dp[i][j]` to represent the state (if substring is palindrome) of `s[i:j]` substring.

* Base cases:
```js
// The character itself is palindrome
dp[i][i] = true

// The length of substring is two
dp[i][i + 1] = (s[i] == s[i + 1])
```

* Recursive cases:
```js
dp[i][j] = dp[i + 1][j - 1] && s[i] == s[j]
```

```kotlin
fun longestPalindrome(s: String): String {
    val dp = Array(s.length) { _ -> BooleanArray(s.length) }
    var result = ""

    // How do we iterate i,j? i expands toward left, j expends toward right.
    // We can iterate in this backward way:
    // for (i in len - 1 downTo 0) {
        // for (j in i + 1 until len) {

    // Or foward way, mind the i, j order.
    for (j in 0 until s.length) {
        for (i in j downTo 0) {

            // Base cases: when length is 1 or 2.
            dp[i][j] = if (i == j || i + 1 == j) s[i] == s[j]
            else dp[i + 1][j - 1] && s[i] == s[j]

            if (dp[i][j]) {
                val currentLength = j - i + 1
                if (currentLength > result.length) {
                    result = s.substring(i..j)
                }
            }
        }
    }
    return result
}   
```

```js
s = "babad"

// Forward way
 i|0 |1 0|2 1 0|3 2 1 0|4 3 2 1 0
 j|0 |1  |2    |3      |4
---------------------------------
dp|O  O X O X O O X O X O X X X X

// Backward
 i|4 |3  |2    |...
 j|4 |3 4|2 3 4|...
```
* **Time Complexity**: `O(n^2)`.
* **Space Complexity**: `O(n^2)`.

### Expand Around Center
For every character, we expand the string to left/right at the same time and see if it's palindrome.

```kotlin
fun longestPalindrome(s: String): String {
    var maxPalindrome = ""
    for (i in 0 until s.length) {
        // check odd length case, like "aba"
        var currentPalindrome = findPalindromeSubstring(s, i, i)
        if (maxPalindrome.length < currentPalindrome.length) {
            maxPalindrome = currentPalindrome
        }
        // check even length case, like "abba", and 
        // we extend from the first "b" from odd length case, it will
        // fail, but it's valid palindrome.
        currentPalindrome = findPalindromeSubstring(s, i, i + 1)
        if (maxPalindrome.length < currentPalindrome.length) {
            maxPalindrome = currentPalindrome
        }
    }
    return maxPalindrome
}

private fun findPalindromeSubstring(s: String, start: Int, end: Int): String {
    var i = start
    var j = end
    if (s.isEmpty() || i > j) return ""
    // Keep expand the palindrome
    while (i >= 0 && j < s.length && s[i] == s[j]) {
        i--
        j++
    }
    return s.slice(i + 1 until j)
}
```

* **Time Complexity**: `O(n^2)`.
* **Space Complexity**: `O(1)`.

#### References
* https://leetcode.com/problems/longest-palindromic-substring/discuss/2954/Python-easy-to-understand-solution-with-comments-(from-middle-to-two-ends).